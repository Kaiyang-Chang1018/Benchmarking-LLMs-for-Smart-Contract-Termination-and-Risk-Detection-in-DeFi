{"IERC20.sol":{"content":"// SPDX-License-Identifier: -- BCOM --\n\npragma solidity =0.8.25;\n\ninterface IERC20 {\n\n    function transfer(\n        address _recipient,\n        uint256 _amount\n    )\n        external\n        returns (bool);\n\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    )\n        external\n        returns (bool);\n\n    function balanceOf(\n        address _account\n    )\n        external\n        view\n        returns (uint256);\n}"},"MerkleProof.sol":{"content":"// SPDX-License-Identifier: -- BCOM --\n\npragma solidity =0.8.25;\n\nlibrary MerkleProof {\n\n    function verify(\n        bytes32[] memory _proof,\n        bytes32 _root,\n        bytes32 _leaf\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        uint256 i;\n        uint256 l = _proof.length;\n        bytes32 computedHash = _leaf;\n\n        while (i \u003c l) {\n\n            bytes32 proofElement = _proof[i];\n\n            computedHash \u003c= proofElement\n                ? computedHash = keccak256(abi.encodePacked(computedHash, proofElement))\n                : computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return computedHash == _root;\n    }\n}\n"},"VerseAirdrop.sol":{"content":"// SPDX-License-Identifier: -- BCOM --\n\npragma solidity =0.8.25;\n\nimport \"./IERC20.sol\";\nimport \"./MerkleProof.sol\";\n\nerror InvalidClaim();\nerror InvalidAmount();\nerror AlreadyCreated();\nerror AlreadyClaimed();\n\n/**\n  * @title Verse Merkle Airdrop\n  * @author Vitally Marinchenko\n  */\n\ncontract VerseAirdrop {\n\n    uint256 public rewardsCount;\n    uint256 public totalRequired;\n    uint256 public totalCollected;\n    uint256 public latestRootAdded;\n\n    address public masterAccount;\n    address public workerAccount;\n\n    struct Reward {\n        bytes32 root;\n        uint256 total;\n        uint256 claimed;\n        uint256 created;\n    }\n\n    IERC20 public immutable REWARD_TOKEN;\n\n    mapping(uint256 =\u003e string) public ipfsData;\n    mapping(bytes32 =\u003e Reward) public rewardsData;\n\n    mapping(bytes32 =\u003e mapping(address =\u003e bool)) public hasClaimed;\n\n    modifier onlyMaster() {\n        require(\n            msg.sender == masterAccount,\n            \"VerseRewards: INVALID_MASTER\"\n        );\n        _;\n    }\n\n    modifier onlyWorker() {\n        require(\n            msg.sender == workerAccount,\n            \"VerseRewards: INVALID_WORKER\"\n        );\n        _;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount\n    );\n\n    event Withdraw(\n        address indexed account,\n        uint256 amount\n    );\n\n    event NewRewards(\n        bytes32 indexed hash,\n        address indexed master,\n        string indexed ipfsAddress,\n        uint256 total\n    );\n\n    event Claimed(\n        uint256 indexed index,\n        address indexed account,\n        uint256 amount\n    );\n\n    event Thanks(\n        address indexed account,\n        uint256 indexed amount\n    );\n\n    event DestroyedRewards(\n        bytes32 indexed hash,\n        address indexed master,\n        string indexed ipfsAddress,\n        uint256 total\n    );\n\n    receive()\n        external\n        payable\n    {\n        payable(masterAccount).transfer(\n            msg.value\n        );\n\n        emit Thanks(\n            msg.sender,\n            msg.value\n        );\n    }\n\n    constructor(\n        address _rewardToken,\n        address _masterAccount,\n        address _workerAccount\n    ) {\n        REWARD_TOKEN = IERC20(\n            _rewardToken\n        );\n\n        masterAccount = _masterAccount;\n        workerAccount = _workerAccount;\n    }\n\n    function createRewards(\n        bytes32 _root,\n        uint256 _total,\n        string calldata _ipfsAddress\n    )\n        external\n        onlyMaster\n    {\n        if (_total == 0) {\n            revert InvalidAmount();\n        }\n\n        bytes32 ipfsHash = getHash(\n            _ipfsAddress\n        );\n\n        if (rewardsData[ipfsHash].total \u003e 0) {\n            revert AlreadyCreated();\n        }\n\n        rewardsData[ipfsHash] = Reward({\n            root: _root,\n            total: _total,\n            created: block.timestamp,\n            claimed: 0\n        });\n\n        rewardsCount =\n        rewardsCount + 1;\n\n        ipfsData[rewardsCount] = _ipfsAddress;\n\n        totalRequired =\n        totalRequired + _total;\n\n        latestRootAdded = block.timestamp;\n\n        emit NewRewards(\n            _root,\n            masterAccount,\n            _ipfsAddress,\n            _total\n        );\n    }\n\n    function destroyRewards(\n        uint256 _index,\n        string calldata ipfsAddress\n    )\n        external\n        onlyMaster\n    {\n        bytes32 ipfsHash = getHash(\n            ipfsAddress\n        );\n\n        Reward storage reward = rewardsData[\n            ipfsHash\n        ];\n\n        totalRequired =\n        totalRequired - (reward.total - reward.claimed);\n\n        delete ipfsData[\n            _index\n        ];\n\n        delete rewardsData[\n            ipfsHash\n        ];\n\n        emit DestroyedRewards(\n            ipfsHash,\n            masterAccount,\n            ipfsData[_index],\n            reward.total\n        );\n    }\n\n    function getHash(\n        string calldata _ipfsAddress\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encodePacked(\n                _ipfsAddress\n            )\n        );\n    }\n\n    function isClaimed(\n        bytes32 _hash,\n        address _account\n    )\n        public\n        view\n        returns (bool)\n    {\n        return hasClaimed[_hash][_account];\n    }\n\n    function isClaimedBulk(\n        bytes32[] calldata _hash,\n        address _account\n    )\n        external\n        view\n        returns (bool[] memory)\n    {\n        uint256 i;\n        uint256 l = _hash.length;\n        bool[] memory result = new bool[](l);\n\n        while (i \u003c l) {\n            result[i] = isClaimed(\n                _hash[i],\n                _account\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return result;\n    }\n\n    function getClaim(\n        bytes32 _hash,\n        uint256 _index,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    )\n        external\n    {\n        _doClaim(\n            _hash,\n            _index,\n            _amount,\n            msg.sender,\n            _merkleProof\n        );\n    }\n\n    function getClaimBulk(\n        bytes32[] calldata _hash,\n        uint256[] calldata _index,\n        uint256[] calldata _amount,\n        bytes32[][] calldata _merkleProof\n    )\n        external\n    {\n        uint256 i;\n        uint256 l = _hash.length;\n\n        while (i \u003c l) {\n            _doClaim(\n                _hash[i],\n                _index[i],\n                _amount[i],\n                msg.sender,\n                _merkleProof[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function giveClaim(\n        bytes32 _hash,\n        uint256 _index,\n        uint256 _amount,\n        address _account,\n        bytes32[] calldata _merkleProof\n    )\n        external\n        onlyWorker\n    {\n        _doClaim(\n            _hash,\n            _index,\n            _amount,\n            _account,\n            _merkleProof\n        );\n    }\n\n    function giveClaimBulk(\n        bytes32[] calldata _hash,\n        uint256[] calldata _index,\n        uint256[] calldata _amount,\n        address[] calldata _account,\n        bytes32[][] calldata _merkleProof\n    )\n        external\n        onlyWorker\n    {\n        uint256 i;\n        uint256 l = _hash.length;\n\n        while (i \u003c l) {\n            _doClaim(\n                _hash[i],\n                _index[i],\n                _amount[i],\n                _account[i],\n                _merkleProof[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _doClaim(\n        bytes32 _hash,\n        uint256 _index,\n        uint256 _amount,\n        address _account,\n        bytes32[] calldata _merkleProof\n    )\n        private\n    {\n        if (isClaimed(_hash, _account) == true) {\n            revert AlreadyClaimed();\n        }\n\n        bytes32 node = keccak256(\n            abi.encodePacked(\n                _index,\n                _account,\n                _amount\n            )\n        );\n\n        require(\n            MerkleProof.verify(\n                _merkleProof,\n                rewardsData[_hash].root,\n                node\n            ),\n            \"VerseRewards: INVALID_PROOF\"\n        );\n\n        totalCollected =\n        totalCollected + _amount;\n\n        rewardsData[_hash].claimed =\n        rewardsData[_hash].claimed + _amount;\n\n        if (rewardsData[_hash].claimed \u003e rewardsData[_hash].total) {\n            revert InvalidClaim();\n        }\n\n        _setClaimed(\n            _hash,\n            _account\n        );\n\n        REWARD_TOKEN.transfer(\n            _account,\n            _amount\n        );\n\n        emit Claimed(\n            _index,\n            _account,\n            _amount\n        );\n    }\n\n    function _setClaimed(\n        bytes32 _hash,\n        address _account\n    )\n        private\n    {\n        hasClaimed[_hash][_account] = true;\n    }\n\n    function donateFunds(\n        uint256 _donationAmount\n    )\n        external\n    {\n        if (_donationAmount == 0) {\n            revert InvalidAmount();\n        }\n\n        REWARD_TOKEN.transferFrom(\n            msg.sender,\n            address(this),\n            _donationAmount\n        );\n\n        emit Deposit(\n            msg.sender,\n            _donationAmount\n        );\n    }\n\n    function withdrawEth(\n        uint256 _amount\n    )\n        external\n        onlyMaster\n    {\n        payable(\n            masterAccount\n        ).transfer(\n            _amount\n        );\n\n        emit Withdraw(\n            masterAccount,\n            _amount\n        );\n    }\n\n    function changeMaster(\n        address _newMaster\n    )\n        external\n        onlyMaster\n    {\n        masterAccount = _newMaster;\n    }\n\n    function changeWorker(\n        address _newWorker\n    )\n        external\n        onlyMaster\n    {\n        workerAccount = _newWorker;\n    }\n\n    function getBalance()\n        public\n        view\n        returns (uint256)\n    {\n        return REWARD_TOKEN.balanceOf(\n            address(this)\n        );\n    }\n\n    function showRemaining(\n        bytes32 _hash\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return rewardsData[_hash].total - rewardsData[_hash].claimed;\n    }\n\n    function showExcess(\n        bytes32 _hash\n    )\n        external\n        view\n        returns (int256)\n    {\n        return int256(getBalance()) - int256(showRemaining(_hash));\n    }\n\n    function showRemaining()\n        public\n        view\n        returns (uint256)\n    {\n        return totalRequired - totalCollected;\n    }\n\n    function showExcess()\n        external\n        view\n        returns (int256)\n    {\n        return int256(getBalance()) - int256(showRemaining());\n    }\n\n    function rescueTokens(\n        address _token,\n        address _target,\n        uint256 _amount\n    )\n        external\n        onlyMaster\n    {\n        IERC20(_token).transfer(\n            _target,\n            _amount\n        );\n    }\n}\n"}}