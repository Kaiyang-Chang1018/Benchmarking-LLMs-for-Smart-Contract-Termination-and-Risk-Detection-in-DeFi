{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}"},"DefaultOperatorFilterer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {OperatorFilterer} from \"./OperatorFilterer.sol\";\n\ncontract DefaultOperatorFilterer is OperatorFilterer {\n    address constant DEFAULT_SUBSCRIPTION = address(0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6);\n\n    constructor() OperatorFilterer(DEFAULT_SUBSCRIPTION, true) {}\n}"},"EnumerableSet.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value\u0027s index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as \u0027swap and pop\u0027).\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue\u0027s index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"},"ERC721A.sol":{"content":"// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport \"./IERC721A.sol\";\n\n/**\n * @dev Interface of ERC721 token receiver.\n */\ninterface ERC721A__IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n/**\n * @title ERC721A\n *\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\n * Non-Fungible Token Standard, including the Metadata extension.\n * Optimized for lower gas during batch mints.\n *\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\n * starting from `_startTokenId()`.\n *\n * Assumptions:\n *\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\n */\ncontract ERC721A is IERC721A {\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\n    struct TokenApprovalRef {\n        address value;\n    }\n\n    // =============================================================\n    //                           CONSTANTS\n    // =============================================================\n\n    // Mask of an entry in packed address data.\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 \u003c\u003c 64) - 1;\n\n    // The bit position of `numberMinted` in packed address data.\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\n\n    // The bit position of `numberBurned` in packed address data.\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\n\n    // The bit position of `aux` in packed address data.\n    uint256 private constant _BITPOS_AUX = 192;\n\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 \u003c\u003c 192) - 1;\n\n    // The bit position of `startTimestamp` in packed ownership.\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\n\n    // The bit mask of the `burned` bit in packed ownership.\n    uint256 private constant _BITMASK_BURNED = 1 \u003c\u003c 224;\n\n    // The bit position of the `nextInitialized` bit in packed ownership.\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\n\n    // The bit mask of the `nextInitialized` bit in packed ownership.\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 \u003c\u003c 225;\n\n    // The bit position of `extraData` in packed ownership.\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\n\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 \u003c\u003c 232) - 1;\n\n    // The mask of the lower 160 bits for addresses.\n    uint256 private constant _BITMASK_ADDRESS = (1 \u003c\u003c 160) - 1;\n\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\n    // This limit is to prevent overflows on the address data entries.\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\n    // is required to cause an overflow, which is unrealistic.\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\n\n    // The `Transfer` event signature is given by:\n    // `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    // =============================================================\n    //                            STORAGE\n    // =============================================================\n\n    // The next token ID to be minted.\n    uint256 private _currentIndex;\n\n    // The number of tokens burned.\n    uint256 private _burnCounter;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to ownership details\n    // An empty struct value does not necessarily mean the token is unowned.\n    // See {_packedOwnershipOf} implementation for details.\n    //\n    // Bits Layout:\n    // - [0..159]   `addr`\n    // - [160..223] `startTimestamp`\n    // - [224]      `burned`\n    // - [225]      `nextInitialized`\n    // - [232..255] `extraData`\n    mapping(uint256 =\u003e uint256) private _packedOwnerships;\n\n    // Mapping owner address to address data.\n    //\n    // Bits Layout:\n    // - [0..63]    `balance`\n    // - [64..127]  `numberMinted`\n    // - [128..191] `numberBurned`\n    // - [192..255] `aux`\n    mapping(address =\u003e uint256) private _packedAddressData;\n\n    // Mapping from token ID to approved address.\n    mapping(uint256 =\u003e TokenApprovalRef) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address =\u003e mapping(address =\u003e bool)) private _operatorApprovals;\n\n    // =============================================================\n    //                          CONSTRUCTOR\n    // =============================================================\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _currentIndex = _startTokenId();\n    }\n\n    // =============================================================\n    //                   TOKEN COUNTING OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the starting token ID.\n     * To change the starting token ID, please override this function.\n     */\n    function _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Returns the next token ID to be minted.\n     */\n    function _nextTokenId() internal view virtual returns (uint256) {\n        return _currentIndex;\n    }\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than `_currentIndex - _startTokenId()` times.\n        unchecked {\n            return _currentIndex - _burnCounter - _startTokenId();\n        }\n    }\n\n    /**\n     * @dev Returns the total amount of tokens minted in the contract.\n     */\n    function _totalMinted() internal view virtual returns (uint256) {\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\n        // and it is initialized to `_startTokenId()`.\n        unchecked {\n            return _currentIndex - _startTokenId();\n        }\n    }\n\n    /**\n     * @dev Returns the total number of tokens burned.\n     */\n    function _totalBurned() internal view virtual returns (uint256) {\n        return _burnCounter;\n    }\n\n    // =============================================================\n    //                    ADDRESS DATA OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the number of tokens in `owner`\u0027s account.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return _packedAddressData[owner] \u0026 _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the number of tokens minted by `owner`.\n     */\n    function _numberMinted(address owner) internal view returns (uint256) {\n        return (_packedAddressData[owner] \u003e\u003e _BITPOS_NUMBER_MINTED) \u0026 _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the number of tokens burned by or on behalf of `owner`.\n     */\n    function _numberBurned(address owner) internal view returns (uint256) {\n        return (_packedAddressData[owner] \u003e\u003e _BITPOS_NUMBER_BURNED) \u0026 _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    function _getAux(address owner) internal view returns (uint64) {\n        return uint64(_packedAddressData[owner] \u003e\u003e _BITPOS_AUX);\n    }\n\n    /**\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    function _setAux(address owner, uint64 aux) internal virtual {\n        uint256 packed = _packedAddressData[owner];\n        uint256 auxCasted;\n        // Cast `aux` with assembly to avoid redundant masking.\n        assembly {\n            auxCasted := aux\n        }\n        packed = (packed \u0026 _BITMASK_AUX_COMPLEMENT) | (auxCasted \u003c\u003c _BITPOS_AUX);\n        _packedAddressData[owner] = packed;\n    }\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        // The interface IDs are constants representing the first 4 bytes\n        // of the XOR of all function selectors in the interface.\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\n    }\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : \u0027\u0027;\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, it can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \u0027\u0027;\n    }\n\n    // =============================================================\n    //                     OWNERSHIPS OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return address(uint160(_packedOwnershipOf(tokenId)));\n    }\n\n    /**\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around over time.\n     */\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\n    }\n\n    /**\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\n     */\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\n        return _unpackedOwnership(_packedOwnerships[index]);\n    }\n\n    /**\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\n     */\n    function _initializeOwnershipAt(uint256 index) internal virtual {\n        if (_packedOwnerships[index] == 0) {\n            _packedOwnerships[index] = _packedOwnershipOf(index);\n        }\n    }\n\n    /**\n     * Returns the packed ownership data of `tokenId`.\n     */\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\n        uint256 curr = tokenId;\n\n        unchecked {\n            if (_startTokenId() \u003c= curr)\n                if (curr \u003c _currentIndex) {\n                    uint256 packed = _packedOwnerships[curr];\n                    // If not burned.\n                    if (packed \u0026 _BITMASK_BURNED == 0) {\n                        // Invariant:\n                        // There will always be an initialized ownership slot\n                        // (i.e. `ownership.addr != address(0) \u0026\u0026 ownership.burned == false`)\n                        // before an unintialized ownership slot\n                        // (i.e. `ownership.addr == address(0) \u0026\u0026 ownership.burned == false`)\n                        // Hence, `curr` will not underflow.\n                        //\n                        // We can directly compare the packed value.\n                        // If the address is zero, packed will be zero.\n                        while (packed == 0) {\n                            packed = _packedOwnerships[--curr];\n                        }\n                        return packed;\n                    }\n                }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\n\n    /**\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\n     */\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\n        ownership.addr = address(uint160(packed));\n        ownership.startTimestamp = uint64(packed \u003e\u003e _BITPOS_START_TIMESTAMP);\n        ownership.burned = packed \u0026 _BITMASK_BURNED != 0;\n        ownership.extraData = uint24(packed \u003e\u003e _BITPOS_EXTRA_DATA);\n    }\n\n    /**\n     * @dev Packs ownership data into a single uint256.\n     */\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\n        assembly {\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren\u0027t clean.\n            owner := and(owner, _BITMASK_ADDRESS)\n            // `owner | (block.timestamp \u003c\u003c _BITPOS_START_TIMESTAMP) | flags`.\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\n        }\n    }\n\n    /**\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\n     */\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\n        // For branchless setting of the `nextInitialized` flag.\n        assembly {\n            // `(quantity == 1) \u003c\u003c _BITPOS_NEXT_INITIALIZED`.\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\n        }\n    }\n\n    // =============================================================\n    //                      APPROVAL OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) public payable virtual override {\n        address owner = ownerOf(tokenId);\n\n        if (_msgSenderERC721A() != owner)\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\n                revert ApprovalCallerNotOwnerNorApproved();\n            }\n\n        _tokenApprovals[tokenId].value = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\n\n        return _tokenApprovals[tokenId].value;\n    }\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted. See {_mint}.\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return\n            _startTokenId() \u003c= tokenId \u0026\u0026\n            tokenId \u003c _currentIndex \u0026\u0026 // If within bounds,\n            _packedOwnerships[tokenId] \u0026 _BITMASK_BURNED == 0; // and not burned.\n    }\n\n    /**\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\n     */\n    function _isSenderApprovedOrOwner(\n        address approvedAddress,\n        address owner,\n        address msgSender\n    ) private pure returns (bool result) {\n        assembly {\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren\u0027t clean.\n            owner := and(owner, _BITMASK_ADDRESS)\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren\u0027t clean.\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\n            // `msgSender == owner || msgSender == approvedAddress`.\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\n        }\n    }\n\n    /**\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\n     */\n    function _getApprovedSlotAndAddress(uint256 tokenId)\n        private\n        view\n        returns (uint256 approvedAddressSlot, address approvedAddress)\n    {\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\n        assembly {\n            approvedAddressSlot := tokenApproval.slot\n            approvedAddress := sload(approvedAddressSlot)\n        }\n    }\n\n    // =============================================================\n    //                      TRANSFER OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable virtual override {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\n\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\n\n        // The nested ifs save around 20+ gas over a compound boolean condition.\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\n\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        // Clear approvals from the previous owner.\n        assembly {\n            if approvedAddress {\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\n                sstore(approvedAddressSlot, 0)\n            }\n        }\n\n        // Underflow of the sender\u0027s balance is impossible because we check for\n        // ownership above and the recipient\u0027s balance can\u0027t realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // We can directly increment and decrement the balances.\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\n\n            // Updates:\n            // - `address` to the next owner.\n            // - `startTimestamp` to the timestamp of transfering.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `true`.\n            _packedOwnerships[tokenId] = _packOwnershipData(\n                to,\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked \u0026 _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot\u0027s address is zero and not burned (i.e. packed value is zero).\n                if (_packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != _currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, \u0027\u0027)`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable virtual override {\n        safeTransferFrom(from, to, tokenId, \u0027\u0027);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public payable virtual override {\n        transferFrom(from, to, tokenId);\n        if (to.code.length != 0)\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\n                revert TransferToNonERC721ReceiverImplementer();\n            }\n    }\n\n    /**\n     * @dev Hook that is called before a set of serially-ordered token IDs\n     * are about to be transferred. This includes minting.\n     * And also called before burning one token.\n     *\n     * `startTokenId` - the first token ID to be transferred.\n     * `quantity` - the amount to be transferred.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`\u0027s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after a set of serially-ordered token IDs\n     * have been transferred. This includes minting.\n     * And also called after one token has been burned.\n     *\n     * `startTokenId` - the first token ID to be transferred.\n     * `quantity` - the amount to be transferred.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`\u0027s `tokenId` has been\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` has been minted for `to`.\n     * - When `to` is zero, `tokenId` has been burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\n     *\n     * `from` - Previous owner of the given token ID.\n     * `to` - Target address that will receive the token.\n     * `tokenId` - Token ID to be transferred.\n     * `_data` - Optional data to send along with the call.\n     *\n     * Returns whether the call correctly returned the expected magic value.\n     */\n    function _checkContractOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\n            bytes4 retval\n        ) {\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                revert TransferToNonERC721ReceiverImplementer();\n            } else {\n                assembly {\n                    revert(add(32, reason), mload(reason))\n                }\n            }\n        }\n    }\n\n    // =============================================================\n    //                        MINT OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event for each mint.\n     */\n    function _mint(address to, uint256 quantity) internal virtual {\n        uint256 startTokenId = _currentIndex;\n        if (quantity == 0) revert MintZeroQuantity();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are incredibly unrealistic.\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\n        // `tokenId` has a maximum limit of 2**256.\n        unchecked {\n            // Updates:\n            // - `balance += quantity`.\n            // - `numberMinted += quantity`.\n            //\n            // We can directly add to the `balance` and `numberMinted`.\n            _packedAddressData[to] += quantity * ((1 \u003c\u003c _BITPOS_NUMBER_MINTED) | 1);\n\n            // Updates:\n            // - `address` to the owner.\n            // - `startTimestamp` to the timestamp of minting.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `quantity == 1`.\n            _packedOwnerships[startTokenId] = _packOwnershipData(\n                to,\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\n            );\n\n            uint256 toMasked;\n            uint256 end = startTokenId + quantity;\n\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\n            // The assembly, together with the surrounding Solidity code, have been\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\n            assembly {\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren\u0027t clean.\n                toMasked := and(to, _BITMASK_ADDRESS)\n                // Emit the `Transfer` event.\n                log4(\n                    0, // Start of data (0, since no data).\n                    0, // End of data (0, since no data).\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\n                    0, // `address(0)`.\n                    toMasked, // `to`.\n                    startTokenId // `tokenId`.\n                )\n\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\n                // that overflows uint256 will make the loop run out of gas.\n                // The compiler will optimize the `iszero` away for performance.\n                for {\n                    let tokenId := add(startTokenId, 1)\n                } iszero(eq(tokenId, end)) {\n                    tokenId := add(tokenId, 1)\n                } {\n                    // Emit the `Transfer` event. Similar to above.\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\n                }\n            }\n            if (toMasked == 0) revert MintToZeroAddress();\n\n            _currentIndex = end;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * This function is intended for efficient minting only during contract creation.\n     *\n     * It emits only one {ConsecutiveTransfer} as defined in\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\n     * instead of a sequence of {Transfer} event(s).\n     *\n     * Calling this function outside of contract creation WILL make your contract\n     * non-compliant with the ERC721 standard.\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {ConsecutiveTransfer} event.\n     */\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\n        uint256 startTokenId = _currentIndex;\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n        if (quantity \u003e _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\n        unchecked {\n            // Updates:\n            // - `balance += quantity`.\n            // - `numberMinted += quantity`.\n            //\n            // We can directly add to the `balance` and `numberMinted`.\n            _packedAddressData[to] += quantity * ((1 \u003c\u003c _BITPOS_NUMBER_MINTED) | 1);\n\n            // Updates:\n            // - `address` to the owner.\n            // - `startTimestamp` to the timestamp of minting.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `quantity == 1`.\n            _packedOwnerships[startTokenId] = _packOwnershipData(\n                to,\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\n            );\n\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\n\n            _currentIndex = startTokenId + quantity;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\n     * - `quantity` must be greater than 0.\n     *\n     * See {_mint}.\n     *\n     * Emits a {Transfer} event for each mint.\n     */\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, quantity);\n\n        unchecked {\n            if (to.code.length != 0) {\n                uint256 end = _currentIndex;\n                uint256 index = end - quantity;\n                do {\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\n                        revert TransferToNonERC721ReceiverImplementer();\n                    }\n                } while (index \u003c end);\n                // Reentrancy protection.\n                if (_currentIndex != end) revert();\n            }\n        }\n    }\n\n    /**\n     * @dev Equivalent to `_safeMint(to, quantity, \u0027\u0027)`.\n     */\n    function _safeMint(address to, uint256 quantity) internal virtual {\n        _safeMint(to, quantity, \u0027\u0027);\n    }\n\n    // =============================================================\n    //                        BURN OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Equivalent to `_burn(tokenId, false)`.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        _burn(tokenId, false);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        address from = address(uint160(prevOwnershipPacked));\n\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\n\n        if (approvalCheck) {\n            // The nested ifs save around 20+ gas over a compound boolean condition.\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\n        }\n\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\n\n        // Clear approvals from the previous owner.\n        assembly {\n            if approvedAddress {\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\n                sstore(approvedAddressSlot, 0)\n            }\n        }\n\n        // Underflow of the sender\u0027s balance is impossible because we check for\n        // ownership above and the recipient\u0027s balance can\u0027t realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // Updates:\n            // - `balance -= 1`.\n            // - `numberBurned += 1`.\n            //\n            // We can directly decrement the balance, and increment the number burned.\n            // This is equivalent to `packed -= 1; packed += 1 \u003c\u003c _BITPOS_NUMBER_BURNED;`.\n            _packedAddressData[from] += (1 \u003c\u003c _BITPOS_NUMBER_BURNED) - 1;\n\n            // Updates:\n            // - `address` to the last owner.\n            // - `startTimestamp` to the timestamp of burning.\n            // - `burned` to `true`.\n            // - `nextInitialized` to `true`.\n            _packedOwnerships[tokenId] = _packOwnershipData(\n                from,\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked \u0026 _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot\u0027s address is zero and not burned (i.e. packed value is zero).\n                if (_packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != _currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, address(0), tokenId);\n        _afterTokenTransfers(from, address(0), tokenId, 1);\n\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\n        unchecked {\n            _burnCounter++;\n        }\n    }\n\n    // =============================================================\n    //                     EXTRA DATA OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Directly sets the extra data for the ownership data `index`.\n     */\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\n        uint256 packed = _packedOwnerships[index];\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\n        uint256 extraDataCasted;\n        // Cast `extraData` with assembly to avoid redundant masking.\n        assembly {\n            extraDataCasted := extraData\n        }\n        packed = (packed \u0026 _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted \u003c\u003c _BITPOS_EXTRA_DATA);\n        _packedOwnerships[index] = packed;\n    }\n\n    /**\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\n     * Intended to be overridden by the cosumer contract.\n     *\n     * `previousExtraData` - the value of `extraData` before transfer.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`\u0027s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _extraData(\n        address from,\n        address to,\n        uint24 previousExtraData\n    ) internal view virtual returns (uint24) {}\n\n    /**\n     * @dev Returns the next extra data for the packed ownership data.\n     * The returned result is shifted into position.\n     */\n    function _nextExtraData(\n        address from,\n        address to,\n        uint256 prevOwnershipPacked\n    ) private view returns (uint256) {\n        uint24 extraData = uint24(prevOwnershipPacked \u003e\u003e _BITPOS_EXTRA_DATA);\n        return uint256(_extraData(from, to, extraData)) \u003c\u003c _BITPOS_EXTRA_DATA;\n    }\n\n    // =============================================================\n    //                       OTHER OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the message sender (defaults to `msg.sender`).\n     *\n     * If you are writing GSN compatible contracts, you need to override this function.\n     */\n    function _msgSenderERC721A() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    /**\n     * @dev Converts a uint256 to its ASCII string decimal representation.\n     */\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\n            let m := add(mload(0x40), 0xa0)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 1)\n                // Write the character to the pointer.\n                // The ASCII index of the \u00270\u0027 character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n}"},"IERC721A.sol":{"content":"// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of ERC721A.\n */\ninterface IERC721A {\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error ApprovalCallerNotOwnerNorApproved();\n\n    /**\n     * The token does not exist.\n     */\n    error ApprovalQueryForNonexistentToken();\n\n    /**\n     * Cannot query the balance for the zero address.\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * Cannot mint to the zero address.\n     */\n    error MintToZeroAddress();\n\n    /**\n     * The quantity of tokens minted must be more than zero.\n     */\n    error MintZeroQuantity();\n\n    /**\n     * The token does not exist.\n     */\n    error OwnerQueryForNonexistentToken();\n\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error TransferCallerNotOwnerNorApproved();\n\n    /**\n     * The token must be owned by `from`.\n     */\n    error TransferFromIncorrectOwner();\n\n    /**\n     * Cannot safely transfer to a contract that does not implement the\n     * ERC721Receiver interface.\n     */\n    error TransferToNonERC721ReceiverImplementer();\n\n    /**\n     * Cannot transfer to the zero address.\n     */\n    error TransferToZeroAddress();\n\n    /**\n     * The token does not exist.\n     */\n    error URIQueryForNonexistentToken();\n\n    /**\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\n     */\n    error MintERC2309QuantityExceedsLimit();\n\n    /**\n     * The `extraData` cannot be set on an unintialized ownership slot.\n     */\n    error OwnershipNotInitializedForExtraData();\n\n    // =============================================================\n    //                            STRUCTS\n    // =============================================================\n\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Stores the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\n        uint24 extraData;\n    }\n\n    // =============================================================\n    //                         TOKEN COUNTERS\n    // =============================================================\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() external view returns (uint256);\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    // =============================================================\n    //                            IERC721\n    // =============================================================\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables\n     * (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in `owner`\u0027s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\n     * checking first that contract recipients are aware of the ERC721 protocol\n     * to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move\n     * this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, \u0027\u0027)`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\n     * whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external payable;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    // =============================================================\n    //                           IERC2309\n    // =============================================================\n\n    /**\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\n     * (inclusive) is transferred from `from` to `to`, as defined in the\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\n     *\n     * See {_mintERC2309} for more details.\n     */\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\n}"},"IOperatorFilterRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {EnumerableSet} from \"./EnumerableSet.sol\";\n\ninterface IOperatorFilterRegistry {\n    function isOperatorAllowed(address registrant, address operator) external returns (bool);\n    function register(address registrant) external;\n    function registerAndSubscribe(address registrant, address subscription) external;\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\n    function updateOperator(address registrant, address operator, bool filtered) external;\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\n    function subscribe(address registrant, address registrantToSubscribe) external;\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\n    function subscriptionOf(address addr) external returns (address registrant);\n    function subscribers(address registrant) external returns (address[] memory);\n    function subscriberAt(address registrant, uint256 index) external returns (address);\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\n    function filteredOperators(address addr) external returns (address[] memory);\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\n    function isRegistered(address addr) external returns (bool);\n    function codeHashOf(address addr) external returns (bytes32);\n}"},"MerkleProof.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs \u0026 pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i \u003c proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash \u003c= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        return computedHash;\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"},"OperatorFilterer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {IOperatorFilterRegistry} from \"./IOperatorFilterRegistry.sol\";\n\ncontract OperatorFilterer {\n    error OperatorNotAllowed(address operator);\n\n    IOperatorFilterRegistry constant operatorFilterRegistry =\n        IOperatorFilterRegistry(0x000000000000AAeB6D7670E522A718067333cd4E);\n\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\n        // order for the modifier to filter addresses.\n        if (address(operatorFilterRegistry).code.length \u003e 0) {\n            if (subscribe) {\n                operatorFilterRegistry.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\n            } else {\n                if (subscriptionOrRegistrantToCopy != address(0)) {\n                    operatorFilterRegistry.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\n                } else {\n                    operatorFilterRegistry.register(address(this));\n                }\n            }\n        }\n    }\n\n    modifier onlyAllowedOperator() virtual {\n        // Check registry code length to facilitate testing in environments without a deployed registry.\n        if (address(operatorFilterRegistry).code.length \u003e 0) {\n            if (!operatorFilterRegistry.isOperatorAllowed(address(this), msg.sender)) {\n                revert OperatorNotAllowed(msg.sender);\n            }\n        }\n        _;\n    }\n}"},"OperatorFilterRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {IOperatorFilterRegistry} from \"./IOperatorFilterRegistry.sol\";\nimport {Ownable} from \"./Ownable.sol\";\nimport {EnumerableSet} from \"./EnumerableSet.sol\";\nimport {OperatorFilterRegistryErrorsAndEvents} from \"./OperatorFilterRegistryErrorsAndEvents.sol\";\n\n/**\n * @title  OperatorFilterRegistry\n * @notice Borrows heavily from the QQL BlacklistOperatorFilter contract:\n *         https://github.com/qql-art/contracts/blob/main/contracts/BlacklistOperatorFilter.sol\n * @notice This contracts allows tokens or token owners to register specific addresses or codeHashes that may be\n * *       restricted according to the isOperatorAllowed function.\n */\ncontract OperatorFilterRegistry is IOperatorFilterRegistry, OperatorFilterRegistryErrorsAndEvents {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /// @dev initialized accounts have a nonzero codehash (see https://eips.ethereum.org/EIPS/eip-1052)\n    /// Note that this will also be a smart contract\u0027s codehash when making calls from its constructor.\n    bytes32 constant EOA_CODEHASH = keccak256(\"\");\n\n    mapping(address =\u003e EnumerableSet.AddressSet) private _filteredOperators;\n    mapping(address =\u003e EnumerableSet.Bytes32Set) private _filteredCodeHashes;\n    mapping(address =\u003e address) private _registrations;\n    mapping(address =\u003e EnumerableSet.AddressSet) private _subscribers;\n\n    /**\n     * @notice restricts method caller to the address or EIP-173 \"owner()\"\n     */\n    modifier onlyAddressOrOwner(address addr) {\n        if (msg.sender != addr) {\n            try Ownable(addr).owner() returns (address owner) {\n                if (msg.sender != owner) {\n                    revert OnlyAddressOrOwner();\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert NotOwnable();\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n        _;\n    }\n\n    /**\n     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns\n     *         true if supplied registrant address is not registered.\n     */\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool) {\n        address registration = _registrations[registrant];\n        if (registration != address(0)) {\n            EnumerableSet.AddressSet storage filteredOperatorsRef;\n            EnumerableSet.Bytes32Set storage filteredCodeHashesRef;\n\n            filteredOperatorsRef = _filteredOperators[registration];\n            filteredCodeHashesRef = _filteredCodeHashes[registration];\n\n            if (filteredOperatorsRef.contains(operator)) {\n                revert AddressFiltered(operator);\n            }\n            if (operator.code.length \u003e 0) {\n                bytes32 codeHash = operator.codehash;\n                if (filteredCodeHashesRef.contains(codeHash)) {\n                    revert CodeHashFiltered(operator, codeHash);\n                }\n            }\n        }\n        return true;\n    }\n\n    //////////////////\n    // AUTH METHODS //\n    //////////////////\n\n    /**\n     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.\n     */\n    function register(address registrant) external onlyAddressOrOwner(registrant) {\n        if (_registrations[registrant] != address(0)) {\n            revert AlreadyRegistered();\n        }\n        _registrations[registrant] = registrant;\n        emit RegistrationUpdated(registrant, true);\n    }\n\n    /**\n     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.\n     *         Note that this does not remove any filtered addresses or codeHashes.\n     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.\n     */\n    function unregister(address registrant) external onlyAddressOrOwner(registrant) {\n        address registration = _registrations[registrant];\n        if (registration == address(0)) {\n            revert NotRegistered(registrant);\n        }\n        if (registration != registrant) {\n            _subscribers[registration].remove(registrant);\n            emit SubscriptionUpdated(registrant, registration, false);\n        }\n        _registrations[registrant] = address(0);\n        emit RegistrationUpdated(registrant, false);\n    }\n\n    /**\n     * @notice Registers an address with the registry and \"subscribes\" to another address\u0027s filtered operators and codeHashes.\n     */\n    function registerAndSubscribe(address registrant, address subscription) external onlyAddressOrOwner(registrant) {\n        address registration = _registrations[registrant];\n        if (registration != address(0)) {\n            revert AlreadyRegistered();\n        }\n        if (registrant == subscription) {\n            revert CannotSubscribeToSelf();\n        }\n        address subscriptionRegistration = _registrations[subscription];\n        if (subscriptionRegistration == address(0)) {\n            revert NotRegistered(subscription);\n        }\n        if (subscriptionRegistration != subscription) {\n            revert CannotSubscribeToRegistrantWithSubscription(subscription);\n        }\n\n        _registrations[registrant] = subscription;\n        _subscribers[subscription].add(registrant);\n        emit RegistrationUpdated(registrant, true);\n        emit SubscriptionUpdated(registrant, subscription, true);\n    }\n\n    /**\n     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another\n     *         address without subscribing.\n     */\n    function registerAndCopyEntries(address registrant, address registrantToCopy)\n        external\n        onlyAddressOrOwner(registrant)\n    {\n        if (registrantToCopy == registrant) {\n            revert CannotCopyFromSelf();\n        }\n        address registration = _registrations[registrant];\n        if (registration != address(0)) {\n            revert AlreadyRegistered();\n        }\n        address registrantRegistration = _registrations[registrantToCopy];\n        if (registrantRegistration == address(0)) {\n            revert NotRegistered(registrantToCopy);\n        }\n        _registrations[registrant] = registrant;\n        emit RegistrationUpdated(registrant, true);\n        _copyEntries(registrant, registrantToCopy);\n    }\n\n    /**\n     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.\n     */\n    function updateOperator(address registrant, address operator, bool filtered)\n        external\n        onlyAddressOrOwner(registrant)\n    {\n        address registration = _registrations[registrant];\n        if (registration == address(0)) {\n            revert NotRegistered(registrant);\n        }\n        if (registration != registrant) {\n            revert CannotUpdateWhileSubscribed(registration);\n        }\n        EnumerableSet.AddressSet storage filteredOperatorsRef = _filteredOperators[registrant];\n\n        if (!filtered) {\n            bool removed = filteredOperatorsRef.remove(operator);\n            if (!removed) {\n                revert AddressNotFiltered(operator);\n            }\n        } else {\n            bool added = filteredOperatorsRef.add(operator);\n            if (!added) {\n                revert AddressAlreadyFiltered(operator);\n            }\n        }\n        emit OperatorUpdated(registrant, operator, filtered);\n    }\n\n    /**\n     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.\n     */\n    function updateCodeHash(address registrant, bytes32 codeHash, bool filtered)\n        external\n        onlyAddressOrOwner(registrant)\n    {\n        if (codeHash == EOA_CODEHASH) {\n            revert CannotFilterEOAs();\n        }\n        address registration = _registrations[registrant];\n        if (registration == address(0)) {\n            revert NotRegistered(registrant);\n        }\n        if (registration != registrant) {\n            revert CannotUpdateWhileSubscribed(registration);\n        }\n        EnumerableSet.Bytes32Set storage filteredCodeHashesRef = _filteredCodeHashes[registrant];\n\n        if (!filtered) {\n            bool removed = filteredCodeHashesRef.remove(codeHash);\n            if (!removed) {\n                revert CodeHashNotFiltered(codeHash);\n            }\n        } else {\n            bool added = filteredCodeHashesRef.add(codeHash);\n            if (!added) {\n                revert CodeHashAlreadyFiltered(codeHash);\n            }\n        }\n        emit CodeHashUpdated(registrant, codeHash, filtered);\n    }\n\n    /**\n     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.\n     */\n    function updateOperators(address registrant, address[] calldata operators, bool filtered)\n        external\n        onlyAddressOrOwner(registrant)\n    {\n        address registration = _registrations[registrant];\n        if (registration == address(0)) {\n            revert NotRegistered(registrant);\n        }\n        if (registration != registrant) {\n            revert CannotUpdateWhileSubscribed(registration);\n        }\n        EnumerableSet.AddressSet storage filteredOperatorsRef = _filteredOperators[registrant];\n        uint256 operatorsLength = operators.length;\n        unchecked {\n            if (!filtered) {\n                for (uint256 i = 0; i \u003c operatorsLength; ++i) {\n                    address operator = operators[i];\n                    bool removed = filteredOperatorsRef.remove(operator);\n                    if (!removed) {\n                        revert AddressNotFiltered(operator);\n                    }\n                }\n            } else {\n                for (uint256 i = 0; i \u003c operatorsLength; ++i) {\n                    address operator = operators[i];\n                    bool added = filteredOperatorsRef.add(operator);\n                    if (!added) {\n                        revert AddressAlreadyFiltered(operator);\n                    }\n                }\n            }\n        }\n        emit OperatorsUpdated(registrant, operators, filtered);\n    }\n\n    /**\n     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.\n     */\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered)\n        external\n        onlyAddressOrOwner(registrant)\n    {\n        address registration = _registrations[registrant];\n        if (registration == address(0)) {\n            revert NotRegistered(registrant);\n        }\n        if (registration != registrant) {\n            revert CannotUpdateWhileSubscribed(registration);\n        }\n        EnumerableSet.Bytes32Set storage filteredCodeHashesRef = _filteredCodeHashes[registrant];\n        uint256 codeHashesLength = codeHashes.length;\n        unchecked {\n            if (!filtered) {\n                for (uint256 i = 0; i \u003c codeHashesLength; ++i) {\n                    bytes32 codeHash = codeHashes[i];\n                    bool removed = filteredCodeHashesRef.remove(codeHash);\n                    if (!removed) {\n                        revert CodeHashNotFiltered(codeHash);\n                    }\n                }\n            } else {\n                for (uint256 i = 0; i \u003c codeHashesLength; ++i) {\n                    bytes32 codeHash = codeHashes[i];\n                    if (codeHash == EOA_CODEHASH) {\n                        revert CannotFilterEOAs();\n                    }\n                    bool added = filteredCodeHashesRef.add(codeHash);\n                    if (!added) {\n                        revert CodeHashAlreadyFiltered(codeHash);\n                    }\n                }\n            }\n        }\n        emit CodeHashesUpdated(registrant, codeHashes, filtered);\n    }\n\n    /**\n     * @notice Subscribe an address to another registrant\u0027s filtered operators and codeHashes. Will remove previous\n     *         subscription if present.\n     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,\n     *         subscriptions will not be forwarded. Instead the former subscription\u0027s existing entries will still be\n     *         used.\n     */\n    function subscribe(address registrant, address newSubscription) external onlyAddressOrOwner(registrant) {\n        if (registrant == newSubscription) {\n            revert CannotSubscribeToSelf();\n        }\n        if (newSubscription == address(0)) {\n            revert CannotSubscribeToZeroAddress();\n        }\n        address registration = _registrations[registrant];\n        if (registration == address(0)) {\n            revert NotRegistered(registrant);\n        }\n        if (registration == newSubscription) {\n            revert AlreadySubscribed(newSubscription);\n        }\n        address newSubscriptionRegistration = _registrations[newSubscription];\n        if (newSubscriptionRegistration == address(0)) {\n            revert NotRegistered(newSubscription);\n        }\n        if (newSubscriptionRegistration != newSubscription) {\n            revert CannotSubscribeToRegistrantWithSubscription(newSubscription);\n        }\n\n        if (registration != registrant) {\n            _subscribers[registration].remove(registrant);\n            emit SubscriptionUpdated(registrant, registration, false);\n        }\n        _registrations[registrant] = newSubscription;\n        _subscribers[newSubscription].add(registrant);\n        emit SubscriptionUpdated(registrant, newSubscription, true);\n    }\n\n    /**\n     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.\n     */\n    function unsubscribe(address registrant, bool copyExistingEntries) external onlyAddressOrOwner(registrant) {\n        address registration = _registrations[registrant];\n        if (registration == address(0)) {\n            revert NotRegistered(registrant);\n        }\n        if (registration == registrant) {\n            revert NotSubscribed();\n        }\n        _subscribers[registration].remove(registrant);\n        _registrations[registrant] = registrant;\n        emit SubscriptionUpdated(registrant, registration, false);\n        if (copyExistingEntries) {\n            _copyEntries(registrant, registration);\n        }\n    }\n\n    /**\n     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.\n     */\n    function copyEntriesOf(address registrant, address registrantToCopy) external onlyAddressOrOwner(registrant) {\n        if (registrant == registrantToCopy) {\n            revert CannotCopyFromSelf();\n        }\n        address registration = _registrations[registrant];\n        if (registration == address(0)) {\n            revert NotRegistered(registrant);\n        }\n        if (registration != registrant) {\n            revert CannotUpdateWhileSubscribed(registration);\n        }\n        address registrantRegistration = _registrations[registrantToCopy];\n        if (registrantRegistration == address(0)) {\n            revert NotRegistered(registrantToCopy);\n        }\n        _copyEntries(registrant, registrantToCopy);\n    }\n\n    /// @dev helper to copy entries from registrantToCopy to registrant and emit events\n    function _copyEntries(address registrant, address registrantToCopy) private {\n        EnumerableSet.AddressSet storage filteredOperatorsRef = _filteredOperators[registrantToCopy];\n        EnumerableSet.Bytes32Set storage filteredCodeHashesRef = _filteredCodeHashes[registrantToCopy];\n        uint256 filteredOperatorsLength = filteredOperatorsRef.length();\n        uint256 filteredCodeHashesLength = filteredCodeHashesRef.length();\n        unchecked {\n            for (uint256 i = 0; i \u003c filteredOperatorsLength; ++i) {\n                address operator = filteredOperatorsRef.at(i);\n                bool added = _filteredOperators[registrant].add(operator);\n                if (added) {\n                    emit OperatorUpdated(registrant, operator, true);\n                }\n            }\n            for (uint256 i = 0; i \u003c filteredCodeHashesLength; ++i) {\n                bytes32 codehash = filteredCodeHashesRef.at(i);\n                bool added = _filteredCodeHashes[registrant].add(codehash);\n                if (added) {\n                    emit CodeHashUpdated(registrant, codehash, true);\n                }\n            }\n        }\n    }\n\n    //////////////////\n    // VIEW METHODS //\n    //////////////////\n\n    /**\n     * @notice Get the subscription address of a given registrant, if any.\n     */\n    function subscriptionOf(address registrant) external view returns (address subscription) {\n        subscription = _registrations[registrant];\n        if (subscription == address(0)) {\n            revert NotRegistered(registrant);\n        } else if (subscription == registrant) {\n            subscription = address(0);\n        }\n    }\n\n    /**\n     * @notice Get the set of addresses subscribed to a given registrant.\n     *         Note that order is not guaranteed as updates are made.\n     */\n    function subscribers(address registrant) external view returns (address[] memory) {\n        return _subscribers[registrant].values();\n    }\n\n    /**\n     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.\n     *         Note that order is not guaranteed as updates are made.\n     */\n    function subscriberAt(address registrant, uint256 index) external view returns (address) {\n        return _subscribers[registrant].at(index);\n    }\n\n    /**\n     * @notice Returns true if operator is filtered by a given address or its subscription.\n     */\n    function isOperatorFiltered(address registrant, address operator) external view returns (bool) {\n        address registration = _registrations[registrant];\n        if (registration != registrant) {\n            return _filteredOperators[registration].contains(operator);\n        }\n        return _filteredOperators[registrant].contains(operator);\n    }\n\n    /**\n     * @notice Returns true if a codeHash is filtered by a given address or its subscription.\n     */\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external view returns (bool) {\n        address registration = _registrations[registrant];\n        if (registration != registrant) {\n            return _filteredCodeHashes[registration].contains(codeHash);\n        }\n        return _filteredCodeHashes[registrant].contains(codeHash);\n    }\n\n    /**\n     * @notice Returns true if the hash of an address\u0027s code is filtered by a given address or its subscription.\n     */\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external view returns (bool) {\n        bytes32 codeHash = operatorWithCode.codehash;\n        address registration = _registrations[registrant];\n        if (registration != registrant) {\n            return _filteredCodeHashes[registration].contains(codeHash);\n        }\n        return _filteredCodeHashes[registrant].contains(codeHash);\n    }\n\n    /**\n     * @notice Returns true if an address has registered\n     */\n    function isRegistered(address registrant) external view returns (bool) {\n        return _registrations[registrant] != address(0);\n    }\n\n    /**\n     * @notice Returns a list of filtered operators for a given address or its subscription.\n     */\n    function filteredOperators(address registrant) external view returns (address[] memory) {\n        address registration = _registrations[registrant];\n        if (registration != registrant) {\n            return _filteredOperators[registration].values();\n        }\n        return _filteredOperators[registrant].values();\n    }\n\n    /**\n     * @notice Returns the set of filtered codeHashes for a given address or its subscription.\n     *         Note that order is not guaranteed as updates are made.\n     */\n    function filteredCodeHashes(address registrant) external view returns (bytes32[] memory) {\n        address registration = _registrations[registrant];\n        if (registration != registrant) {\n            return _filteredCodeHashes[registration].values();\n        }\n        return _filteredCodeHashes[registrant].values();\n    }\n\n    /**\n     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or\n     *         its subscription.\n     *         Note that order is not guaranteed as updates are made.\n     */\n    function filteredOperatorAt(address registrant, uint256 index) external view returns (address) {\n        address registration = _registrations[registrant];\n        if (registration != registrant) {\n            return _filteredOperators[registration].at(index);\n        }\n        return _filteredOperators[registrant].at(index);\n    }\n\n    /**\n     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or\n     *         its subscription.\n     *         Note that order is not guaranteed as updates are made.\n     */\n    function filteredCodeHashAt(address registrant, uint256 index) external view returns (bytes32) {\n        address registration = _registrations[registrant];\n        if (registration != registrant) {\n            return _filteredCodeHashes[registration].at(index);\n        }\n        return _filteredCodeHashes[registrant].at(index);\n    }\n\n    /// @dev Convenience method to compute the code hash of an arbitrary contract\n    function codeHashOf(address a) external view returns (bytes32) {\n        return a.codehash;\n    }\n}"},"OperatorFilterRegistryErrorsAndEvents.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ncontract OperatorFilterRegistryErrorsAndEvents {\n    error CannotFilterEOAs();\n    error AddressAlreadyFiltered(address operator);\n    error AddressNotFiltered(address operator);\n    error CodeHashAlreadyFiltered(bytes32 codeHash);\n    error CodeHashNotFiltered(bytes32 codeHash);\n    error OnlyAddressOrOwner();\n    error NotRegistered(address registrant);\n    error AlreadyRegistered();\n    error AlreadySubscribed(address subscription);\n    error NotSubscribed();\n    error CannotUpdateWhileSubscribed(address subscription);\n    error CannotSubscribeToSelf();\n    error CannotSubscribeToZeroAddress();\n    error NotOwnable();\n    error AddressFiltered(address filtered);\n    error CodeHashFiltered(address account, bytes32 codeHash);\n    error CannotSubscribeToRegistrantWithSubscription(address registrant);\n    error CannotCopyFromSelf();\n\n    event RegistrationUpdated(address indexed registrant, bool indexed registered);\n    event OperatorUpdated(address indexed registrant, address indexed operator, bool indexed filtered);\n    event OperatorsUpdated(address indexed registrant, address[] operators, bool indexed filtered);\n    event CodeHashUpdated(address indexed registrant, bytes32 indexed codeHash, bool indexed filtered);\n    event CodeHashesUpdated(address indexed registrant, bytes32[] codeHashes, bool indexed filtered);\n    event SubscriptionUpdated(address indexed registrant, address indexed subscription, bool indexed subscribed);\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"},"Ownable2Step.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() external {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"},"OwnedRegistrant.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {IOperatorFilterRegistry} from \"./IOperatorFilterRegistry.sol\";\nimport {Ownable2Step} from \"./Ownable2Step.sol\";\n\n/**\n * @title  OwnedRegistrant\n * @notice Ownable contract that registers itself with the OperatorFilterRegistry and administers its own entries,\n *         to facilitate a subscription whose ownership can be transferred.\n */\ncontract OwnedRegistrant is Ownable2Step {\n    address constant registry = 0x000000000000AAeB6D7670E522A718067333cd4E;\n\n    constructor(address _owner) {\n        IOperatorFilterRegistry(registry).register(address(this));\n        transferOwnership(_owner);\n    }\n}"},"ParadiseofCookies.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n/*\n\n    ▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒\n    ▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒\n    ▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒\n    ▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒\n    ▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒\n    ▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░│││││││\u0027\u0027\u0027\u0027\u0027│││││││░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒\n    ▒▒░░░░░░░░░░░░░░░░░░░░░░░░││││¡▄▄╗╗▄▄,▄#╬╬╬╬▀╗▄,;▄▄;\u0027││░░░░░░░░░░░░░░░░░░░░░░░░▒\n    ▒░░░░░░░░░░░░░░░░░░░░░░│││\u0027\u0027╓@╬╬╬╬╣╣╬╬╬╠╠╠╠╩╙╙╙╙░░░││▀╗µ││░░░░░░░░░░░░░░░░░░░░░░\n    ▒░░░░░░░░░░░░░░░░░░░│││\u0027.▄▓╬╬╬╬╬╬╠╠╠╠╠╠╩╩╙░░░░╬ \" ¼░░░░▓▄\u0027│││░░░░░░░░░░░░░░░░░░░\n    ▒░░░░░░░░░░░░░░░░░│││\u0027\u0027╓▓╬╬╬╣╬╬╬╬╬╠╠░░░░░░░░░░≡ -,ô░░░░░│╙▀▀W▄│░░░░░░░░░░░░░░░░░\n    ▒░░░░░░░░░░░░░░░░││\u0027\u0027 ▄╬╬╬╬╠╠╠╩╙╙░░░░░░░░░░░░░░░;░░░░░░░░░░░░╙▌││░░░░░░░░░░░░░░░\n    ░░░░░░░░░░░░░░░││\u0027\u0027▄▓▓╬╬╣╩╙╙╙╬░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░╠▒││░░░░░░░░░░░░░░\n    ░░░░░░░░░░░░░░││\u0027\u0027▐╬╬╬╬╬▒,.⌐ ╓░░░░░░░░Q▄▓▓▄░░░░░░░░░░░░░░░░░░░░╙bQ│░░░░░░░░░░░░░\n    ░░░░░░░░░░░░░││\u0027\u0027 ╟╬╬╬╬╬╬╬╓,▄╩░░░░░░░░,┘` \"╢▀░░░░░░#▀╩╩▒░░░░░░░░≤░▌│░░░░░░░░░░░░\n    ░░░░░░░░░░░░░│\u0027\u0027  ▐╬╬╬╬╣╬╠╠╠╠░░░░░░░░@      └░░░░░░╩    ╙░░░░░░░░╚▌││░░░░░░░░░░░\n    ░░░░░░░░░░░░││\u0027  ▄▓╬╬╬╬╬╠╬╬╠╩░░░░░░░░▒ ╔▓µ#╗ ╠░░░░╠⌐,╖,╖ ╞░░░░░░Γ ╝µ│░░░░░░░░░░░\n    ░░░░░░░░░░░░│\u0027\u0027.▓╬╬╬╬╬╬╠╠╠╠░░░░░░░░░░▒ ╣▌ ╟▓ φ░░░░╞⌐╟▌`▓Γ⌠░░░░░░,  ╙▄¡░░░░░░░░░░\n    ░░░░░░░░░░░││\u0027 ▐╬╬╬╬╬╠╠╠╠╠▒≥░░░░░░░░░║╦ ╙▓▀ ,░░░░░░╬ ╙▀  ╩░░░░░░│░░½▌¡░░░░░░░░░░\n    ░░░░░░░░░░░││\u0027 \u0027▓╬╬╬▒╠╠╠╠╠\u0027 ]╔ê░░░░░░░╙▄,,,φ│░░░░░░│╠≥≥≤▒░░░░░░░░░╣▌│¡░░░░░░░░░░\n    ░░░░░░░░░░░░│┐  ╙▓╬╬▓╣▒╠╠▒  ╠░░░░░░░░░│░░░░│░░░╓▒░░░░░░░░φ░░░░░░░.░▓│░░░░░░░░░░░\n    ░░░░░░░░░░░░│┐.  ▐╬╬╬╣▒╠╠╬▒╩░]╙,└ ╛`▒░░░░░░░░░▓▀│╠▒░░░╙,╙⌐ ╙░░░░;░░▌│░░░░░░░░░░░\n    ░░░░░░░░░░░░░│┐. ▓╝╝╣╬╠╬╠╬╠╦╔\".  ,\u0027Æ▌╠░░░░░░░░││)│░░░▐ ⌐` `└▒░░░░░╫\u0027¡░░░░░░░░░░░\n    ░░░░░░░░░░░░░││..╟^~▀└╣╬╠╠╠╠╠⌐φ=     ╠;░░░░)▄▒▄é╬Q∩╩│░░≥╓Γφ░░░Γ;░φ▒¡░░░░░░░░░░░░\n    ░░░░░░░░░░░░░░││┐ ▀ç▄ ╣▒╠╠╠╠╠▒%, │▀╓∩│░░░░░░╫▓▓██▓▓░░░░░░░░░░;░╓▓▀│░░░░░░░░░░░░░\n    ░░░░░░░░░░░░░░░░│┐.\u0027╙╣╬▓▒╠╠╠╠▒░░▒░;≤░░░░░░░░░╫╬▓▓╣▒▒░░░░░░░;░░#╙\u0027¡░░░░░░░░░░░░░░\n    ▒░░░░░░░░░░░░░░░░││┐. ▓╬╬╣╠╠╠╠╠╠╠╠▒░░░░░░░░░░░││││░░░░░░░\";░░å\u0027│░░░░░░░░░░░░░░░░\n    ▒░░░░░░░░░░░░░░░░░░││┌\u0027▓╬╬╣╣╣╣╣╣╬╠╠╠▒░░░░░░░░░░░░░░░░░░░;░░▄╩,¡░░░░░░░░░░░░░░░░░\n    ▒░░░░░░░░░░░░░░░░░░░░││\u0027╙▀▓╬╬╬╣╬╠╠╠╠╠╠φφφφ╦░   \"░░╔Q ² ╠Ä▀╙.¡░░░░░░░░░░░░░░░░░░░\n    ▒░░░░░░░░░░░░░░░░░░░░░░░││┌\u0027╙▀╬╬╣▓╣╣╣╣╣╣╣▒╠╠▒╦╥╓φ▒╠▄▄▄▀╙│¡░░░░░░░░░░░░░░░░░░░░░░\n    ▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░││└╙▀▀▀▀▀▀▀▀╝▓╬╬╬╬╣▓▀╙^┐┐¡░░░░░░░░░░░░░░░░░░░░░░░░░░\n    ▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░¡│││,▄▄▓░╙╙│░▓ƒ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒\n    ▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▄▓╬╩╩▀▀▀▀╡░#╩╩▀▀▄░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒\n    ▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░▓╬╠▒░░░░░░░░░░░░░░▀▒░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒\n    ▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░▐▓╬▒░░░░╠└╓─ ╛\"▒░)░░╫░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒\n    ▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▓╬╠░░]▓▒ ~  ╓\u0027Θ▀╠▐▒░░▌░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒\n    ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░█╬╠░░▓╬▒ ≥\"\u0027,,  ▒╫╬░░╫░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒\n\n    */\nimport \"./ERC721A.sol\";\nimport \"./Ownable.sol\";\nimport \"./DefaultOperatorFilterer.sol\";\nimport \"./MerkleProof.sol\";\n\n    contract ParadiseofCookies is ERC721A, Ownable, DefaultOperatorFilterer {\n    uint256 public price;   \n    uint256 public maxSupply;\n    address private withdrawWallet;\n    string baseURI;\n    string public baseExtension;   \n    bytes32 public root;\n\n    constructor() ERC721A(\"Paradise of Cookies\", \"POC\") {\n        root = 0xe4a70dade03b10d1637a538a313730762b8d44effddcd168e0606cce142c593d;\n        price = 0.05 ether;\n        maxSupply = 420;\n        baseExtension = \".json\";\n        baseURI = \"\";\n        withdrawWallet = address(msg.sender);\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseURI;\n    }\n\n\n    function setBaseURI(string memory _newBaseURI) public onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    function setTreeRoot(bytes32 newroot) public onlyOwner {\n        root = newroot;\n    }\n    \n    function setWithdrawWallet(address wallet) public onlyOwner {\n        withdrawWallet = wallet;\n    }\n\n    function setBaseExtension(string memory _newBaseExtension) public onlyOwner {\n        baseExtension = _newBaseExtension;\n    }\n\n    function withdraw() public payable onlyOwner {\n        (bool os, ) = payable(withdrawWallet).call{value: address(this).balance}(\"\");\n        require(os);\n    }\n\n    function mint(uint256 _mintAmount, bytes32[] memory proof) external payable {\n        require(totalSupply() + _mintAmount \u003c= maxSupply);\n        require(isValid(proof, keccak256(abi.encodePacked(msg.sender))), \"Not a part of Allowlist\");\n        _mint(msg.sender, _mintAmount);\n    }\n\n    function publicMint(uint256 _mintAmount) external payable {\n        require(totalSupply() + _mintAmount \u003c= maxSupply);\n        require(msg.value \u003e= price * _mintAmount);\n        _mint(msg.sender, _mintAmount);\n    }\n\n    function isValid(bytes32[] memory proof, bytes32 leaf) public view returns (bool) {\n        return MerkleProof.verify(proof, root, leaf);\n    }\n\n    function _startTokenId() internal view virtual override(ERC721A) returns (uint256) {\n        return 1;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override(ERC721A) returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(_baseURI(), _toString(tokenId), baseExtension)) : \u0027\u0027;\n    }\n\n    function transferFrom(address from,address to, uint256 tokenId) public payable override(ERC721A) onlyAllowedOperator {\n        super.transferFrom(from, to, tokenId);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) public payable override(ERC721A) onlyAllowedOperator {\n        super.safeTransferFrom(from, to, tokenId);\n    }\n\n    function safeTransferFrom(address from, address to,uint256 tokenId, bytes memory data) public payable override(ERC721A) onlyAllowedOperator {\n        super.safeTransferFrom(from, to, tokenId, data);\n    }\n}"}}