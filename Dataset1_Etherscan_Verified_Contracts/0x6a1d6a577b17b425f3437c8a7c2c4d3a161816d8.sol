{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller\u0027s account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n\ninterface IERC20Metadata is IERC20 {\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n\ninterface IERC20Errors {\n\n    error ERC20InsufficientBalance(\n        address sender,\n        uint256 balance,\n        uint256 needed\n    );\n\n    error ERC20InvalidSender(address sender);\n\n    error ERC20InvalidReceiver(address receiver);\n\n    error ERC20InsufficientAllowance(\n        address spender,\n        uint256 allowance,\n        uint256 needed\n    );\n\n    error ERC20InvalidApprover(address approver);\n\n    error ERC20InvalidSpender(address spender);\n}"},"main.sol":{"content":"/*\nSeamless staking, non-collateralization, instant liquidity, and effortless borrowingâ€”Pillar Finance streamlines your DeFi experience from asset management to loan execution\n\nWebsite: Pillarfi.io\nX: https://x.com/pillarrwa?s=21\nPortal: https://t.me/pillar_rwa\nWhitepaper: Docs.pillarfi.io\n*/\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.27;\n\nimport \"./IERC20.sol\";\nimport \"./ownable.sol\";\nimport \"./UniswapV2.sol\";\n\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address =\u003e uint256) private _balances;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 value)\n        public\n        virtual\n        returns (bool)\n    {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    function _update(\n        address from,\n        address to,\n        uint256 value\n    ) internal virtual {\n        if (from == address(0)) {\n\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance \u003c value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value,\n        bool emitEvent\n    ) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance \u003c value) {\n                revert ERC20InsufficientAllowance(\n                    spender,\n                    currentAllowance,\n                    value\n                );\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n\ncontract PillarFi is Ownable, ERC20 {\n    IUniswapV2Router public immutable uniswapV2Router;\n\n    address public constant ZERO_ADDRESS = address(0);\n    address public constant DEAD_ADDRESS = address(0xdEaD);\n\n    address public uniswapV2Pair;\n    address public VaultWallet;\n    address public OperationsWallet;\n    address public AdminWallet;\n    address public MarketingWallet;\n\n    bool public isLimitsActivated;\n    bool public isDelayEnabled;\n    bool public isTaxEnabled;\n    bool private inSwapBack;\n    bool public isLaunched;\n\n    uint256 public launchBlock;\n    uint256 public launchTime;\n\n    uint256 private lastSwapBackExecutionBlock;\n\n    uint256 public maxBuy;\n    uint256 public maxSell;\n    uint256 public maxWallet;\n\n    uint256 public swapTokensAtAmount;\n    uint256 public buyFee;\n    uint256 public sellFee;\n    uint256 public transferFee;\n\n    mapping(address =\u003e bool) public isExcludedFromFees;\n    mapping(address =\u003e bool) public isExcludedFromLimits;\n    mapping(address =\u003e bool) public automatedMarketMakerPairs;\n    mapping(address =\u003e uint256) private _holderLastTransferTimestamp;\n\n    event Launch();\n    event SetLimitsEnabled(bool status);\n    event SetDelayEnabled(bool status);\n    event SetTaxesEnabled(bool status);\n    event SetMaxBuy(uint256 amount);\n    event SetMaxSell(uint256 amount);\n    event SetMaxWallet(uint256 amount);\n    event SetSwapTokensAtAmount(uint256 newValue, uint256 oldValue);\n    event SetBuyFees(uint256 newValue, uint256 oldValue);\n    event SetSellFees(uint256 newValue, uint256 oldValue);\n    event SetTransferFees(uint256 newValue, uint256 oldValue);\n    event ExcludeFromFees(address account, bool isExcluded);\n    event ExcludeFromLimits(address account, bool isExcluded);\n    event SetAutomatedMarketMakerPair(address pair, bool value);\n    event WithdrawStuckTokens(address token, uint256 amount);\n\n    error AlreadyLaunched();\n    error AddressZero();\n    error AmountTooLow();\n    error AmountTooHigh();\n    error FeeTooHigh();\n    error AMMAlreadySet();\n    error NoNativeTokens();\n    error NoTokens();\n    error FailedToWithdrawNativeTokens();\n    error BotDetected();\n    error TransferDelay();\n    error MaxBuyAmountExceed();\n    error MaxSellAmountExceed();\n    error MaxWalletAmountExceed();\n    error NotLaunched();\n\n    modifier lockSwapBack() {\n        inSwapBack = true;\n        _;\n        inSwapBack = false;\n    }\n\n    constructor() Ownable(msg.sender) ERC20(\"PillarFi\", \"PILLAR\") {\n        address sender = msg.sender;\n        _mint(sender, 100_000_000 ether);\n        uint256 totalSupply = totalSupply();\n\n        VaultWallet = 0x80147E17c7128922B4c7C19941f10CD8D77d3332; //40\n        OperationsWallet = 0x8f34Ce8C621e72C5ad72529067da75F0B579DB3D; //28\n        AdminWallet = 0xD6166b9E361DFc5fe73cb19F82747EE24C6c34da; //16\n        MarketingWallet = 0x0F4d6319F7b2e3e95A1A9c8B1D81D2a388247f8b; //16\n\n        maxBuy = (totalSupply * 9) / 1000;\n        maxSell = (totalSupply * 9) / 1000;\n        maxWallet = (totalSupply * 9) / 1000;\n        swapTokensAtAmount = (totalSupply * 3) / 10000;\n\n        isLimitsActivated = true;\n        isDelayEnabled = true;\n        isTaxEnabled = true;\n\n        buyFee = 33;\n        sellFee = 45;\n        transferFee = 45;\n\n        uniswapV2Router = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n        _excludeFromFees(address(this), true);\n        _excludeFromFees(address(0xdead), true);\n        _excludeFromFees(sender, true);\n        _excludeFromFees(VaultWallet, true);\n        _excludeFromFees(MarketingWallet, true);\n        _excludeFromLimits(address(this), true);\n        _excludeFromLimits(address(0xdead), true);\n        _excludeFromLimits(sender, true);\n        _excludeFromLimits(VaultWallet, true);\n        _excludeFromLimits(MarketingWallet, true);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    function _transferOwnership(address newOwner) internal override {\n        address oldOwner = owner();\n        if (oldOwner != address(0)) {\n            _excludeFromFees(oldOwner, false);\n            _excludeFromLimits(oldOwner, false);\n        }\n        _excludeFromFees(newOwner, true);\n        _excludeFromLimits(newOwner, true);\n        super._transferOwnership(newOwner);\n    }\n\n    function OpenTrading() external onlyOwner {\n        require(!isLaunched, AlreadyLaunched());\n\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(\n            address(this),\n            uniswapV2Router.WETH()\n        );\n\n        _setAutomatedMarketMakerPair(uniswapV2Pair, true);\n        _approve(address(this), address(uniswapV2Router), type(uint256).max);\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\n        isLaunched = true;\n        launchBlock = block.number;\n        launchTime = block.timestamp;\n        emit Launch();\n    }\n\n    function DisableLimits() external onlyOwner {\n        isLimitsActivated = false;\n        emit SetLimitsEnabled(false);\n    }\n\n    function RemoveDelay() external onlyOwner {\n        isDelayEnabled = false;\n        emit SetDelayEnabled(false);\n    }\n      \n    function ToogleTaxes(bool value) external onlyOwner {\n        isTaxEnabled = value;\n        emit SetTaxesEnabled(value);\n    }\n\n    function setSwapTokensAtAmount(uint256 amount) external onlyOwner {\n        uint256 _totalSupply = totalSupply();\n        require(amount \u003e= (_totalSupply * 1) / 1000000, AmountTooLow());\n        require(amount \u003c= (_totalSupply * 5) / 1000, AmountTooHigh());\n        uint256 oldValue = swapTokensAtAmount;\n        swapTokensAtAmount = amount;\n        emit SetSwapTokensAtAmount(amount, oldValue);\n    }\n\n    function excludeFromFees(address[] calldata accounts, bool value)\n        external\n        onlyOwner\n    {\n        for (uint256 i = 0; i \u003c accounts.length; i++) {\n            _excludeFromFees(accounts[i], value);\n        }\n    }\n\n    function excludeFromLimits(address[] calldata accounts, bool value)\n        external\n        onlyOwner\n    {\n        for (uint256 i = 0; i \u003c accounts.length; i++) {\n            _excludeFromLimits(accounts[i], value);\n        }\n    }\n\n    function _excludeFromFees(address account, bool value) internal virtual {\n        isExcludedFromFees[account] = value;\n        emit ExcludeFromFees(account, value);\n    }\n\n    function _excludeFromLimits(address account, bool value) internal virtual {\n        isExcludedFromLimits[account] = value;\n        emit ExcludeFromLimits(account, value);\n    }\n\n    function withdrawStuckTokens(address _token) external onlyOwner {\n        address sender = msg.sender;\n        uint256 amount;\n        if (_token == ZERO_ADDRESS) {\n            bool success;\n            amount = address(this).balance;\n            require(amount \u003e 0, NoNativeTokens());\n            (success, ) = address(sender).call{value: amount}(\"\");\n            require(success, FailedToWithdrawNativeTokens());\n        } else {\n            amount = IERC20(_token).balanceOf(address(this));\n            require(amount \u003e 0, NoTokens());\n            IERC20(_token).transfer(msg.sender, amount);\n        }\n        emit WithdrawStuckTokens(_token, amount);\n    }\n\n    function _update(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        address origin = tx.origin;\n\n        require(\n            isLaunched ||\n                isExcludedFromLimits[from] ||\n                isExcludedFromLimits[to],\n            NotLaunched()\n        );\n\n        bool limits = isLimitsActivated \u0026\u0026\n            !inSwapBack \u0026\u0026\n            !(isExcludedFromLimits[from] || isExcludedFromLimits[to]);\n        if (limits) {\n            if (\n                from != owner() \u0026\u0026\n                to != owner() \u0026\u0026\n                to != ZERO_ADDRESS \u0026\u0026\n                to != DEAD_ADDRESS\n            ) {\n                if (isDelayEnabled) {\n                    if (to != address(uniswapV2Router) \u0026\u0026 to != uniswapV2Pair) {\n                        require(\n                            _holderLastTransferTimestamp[origin] \u003c\n                                block.number - 3 \u0026\u0026\n                                _holderLastTransferTimestamp[to] \u003c\n                                block.number - 3,\n                            TransferDelay()\n                        );\n                        _holderLastTransferTimestamp[origin] = block.number;\n                        _holderLastTransferTimestamp[to] = block.number;\n                    }\n                }\n\n                if (\n                    automatedMarketMakerPairs[from] \u0026\u0026 !isExcludedFromLimits[to]\n                ) {\n                    require(amount \u003c= maxBuy, MaxBuyAmountExceed());\n                    require(\n                        amount + balanceOf(to) \u003c= maxWallet,\n                        MaxWalletAmountExceed()\n                    );\n                } else if (\n                    automatedMarketMakerPairs[to] \u0026\u0026 !isExcludedFromLimits[from]\n                ) {\n                    require(amount \u003c= maxSell, MaxSellAmountExceed());\n                } else if (!isExcludedFromLimits[to]) {\n                    require(\n                        amount + balanceOf(to) \u003c= maxWallet,\n                        MaxWalletAmountExceed()\n                    );\n                }\n            }\n        }\n\n        bool takeFee = isTaxEnabled \u0026\u0026\n            !inSwapBack \u0026\u0026\n            !(isExcludedFromFees[from] || isExcludedFromFees[to]);\n\n        if (takeFee) {\n            uint256 fees = 0;\n            if (automatedMarketMakerPairs[to] \u0026\u0026 sellFee \u003e 0) {\n                fees = (amount * sellFee) / 100;\n            } else if (automatedMarketMakerPairs[from] \u0026\u0026 buyFee \u003e 0) {\n                fees = (amount * buyFee) / 100;\n            } else if (\n                !automatedMarketMakerPairs[to] \u0026\u0026\n                !automatedMarketMakerPairs[from] \u0026\u0026\n                transferFee \u003e 0\n            ) {\n                fees = (amount * transferFee) / 100;\n            }\n\n            if (fees \u003e 0) {\n                amount -= fees;\n                super._update(from, address(this), fees);\n            }\n        }\n\n        uint256 balance = balanceOf(address(this));\n        bool shouldSwap = balance \u003e= swapTokensAtAmount;\n\n        uint256 maxSwapAmount = swapTokensAtAmount * 20;\n        if (takeFee \u0026\u0026 !automatedMarketMakerPairs[from] \u0026\u0026 shouldSwap) {\n            if (block.number \u003e lastSwapBackExecutionBlock) {\n                if (balance \u003e maxSwapAmount) {\n                    balance = maxSwapAmount;\n                }\n                _swapBack(balance);\n                lastSwapBackExecutionBlock = block.number;\n            }\n        }\n\n        super._update(from, to, amount);\n    }\n\n    function _swapBack(uint256 balance) internal virtual lockSwapBack {\n        bool success;\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            balance,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        uint256 ethBalance = address(this).balance;\n\n        uint256 ethForVault = (ethBalance * 40) / 100;\n        uint256 ethForOperation = (ethBalance * 28) / 100;\n        uint256 ethForAdmin = (ethBalance * 16) / 100;\n        uint256 ethForMarketing = (ethBalance * 16) / 100;\n\n        (success, ) = address(VaultWallet).call{value: ethForVault}(\"\");\n        (success, ) = address(OperationsWallet).call{value: ethForOperation}(\"\");\n        (success, ) = address(AdminWallet).call{value: ethForAdmin}(\"\");\n        (success, ) = address(MarketingWallet).call{value: ethForMarketing}(\"\");\n    }\n\n    function manualswap(uint256 _percen) external onlyOwner {\n        uint256 balance = balanceOf(address(this));\n        uint256 amt = (balance * _percen)/100;\n        _swapBack(amt);\n    }\n\n    function ReduceBuyFees(uint256 _buyFee) external onlyOwner {\n        if (block.number == launchBlock){\n            buyFee = _buyFee;\n        } else {\n        require(_buyFee \u003c= buyFee, FeeTooHigh());\n        uint256 oldValue = buyFee;\n        buyFee = _buyFee;\n        emit SetBuyFees(_buyFee, oldValue);\n    }}\n\n    function ReduceSellFees(uint256 _sellFee) external onlyOwner {\n        require(_sellFee \u003c= sellFee, FeeTooHigh());\n        uint256 oldValue = sellFee;\n        sellFee = _sellFee;\n        transferFee = sellFee;\n        emit SetTransferFees(sellFee, oldValue);\n        emit SetSellFees(_sellFee, oldValue);\n    }\n\n    function ReduceTransferFees(uint256 _transferFee) external onlyOwner {\n        require(_transferFee \u003c= transferFee, FeeTooHigh());\n        uint256 oldValue = transferFee;\n        transferFee = _transferFee;\n        emit SetTransferFees(_transferFee, oldValue);\n    }\n\n    function SetTaxWallets(address _OperationWallet, address _VaultAddress, address _AdminWallet, address _MarketingAddress) external onlyOwner {\n        VaultWallet = _VaultAddress;\n        OperationsWallet = _OperationWallet;\n        AdminWallet = _AdminWallet;\n        MarketingWallet = _MarketingAddress;\n        \n    }\n\n    function _setAutomatedMarketMakerPair(address pair, bool value)\n        internal\n        virtual\n    {\n        automatedMarketMakerPairs[pair] = value;\n        emit SetAutomatedMarketMakerPair(pair, value);\n    }\n}"},"ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    error OwnableUnauthorizedAccount(address account);\n\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"},"UniswapV2.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IUniswapV2Router {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n}\ninterface IUniswapV2Factory {\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n}"}}