{"Counters.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n */\r\nlibrary Counters {\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library\u0027s function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value \u003e 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n"},"inputData.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\ncontract inputData {\r\n    string constant p1 = \u0027{\"p\":\"erc-20\",\"op\":\"deploy\",\"tick\":\"\u0027;\r\n    string constant m1 = \u0027\",\"max\":\"\u0027;\r\n  \r\n    function mintData(string memory tick, string memory amt)\r\n        public\r\n        pure\r\n        returns (string memory json, bytes memory jsonHex)\r\n    {\r\n       \r\n        json = mintString(tick,amt);\r\n        jsonHex = bytes(json);\r\n    }\r\n\r\n    function mintString(string memory tick, string memory amt)\r\n        internal   \r\n        pure\r\n        returns (string memory json)\r\n    {\r\n        string memory p = \u0027{\"p\":\"erc-20\",\"op\":\"mint\",\"tick\":\"\u0027;\r\n        string memory m = \u0027\",\"amt\":\"\u0027;\r\n        string memory s = \u0027\"}\u0027;\r\n        json = string(abi.encodePacked(p, tick, m, amt, s));\r\n    }\r\n   \r\n    function transferData(\r\n        string memory tick,\r\n        string memory to,\r\n        string memory amt\r\n    ) public pure returns (string memory json, bytes memory jsonHex) {\r\n        string memory p = \u0027{\"p\":\"erc-20\",\"op\":\"transfer\",\"tick\":\"\u0027;\r\n        string memory m = \u0027\",\"amt\":\"\u0027;\r\n        string memory m2 = \u0027\", \"to\":\"\u0027;\r\n        string memory s = \u0027\"}\u0027;\r\n        json = string(abi.encodePacked(p, tick, m, amt, m2, to, s));\r\n        jsonHex = bytes(json);\r\n    }\r\n\r\n    function depyoyData(\r\n        string memory tick,\r\n        string memory max,\r\n        string memory lim,\r\n        string memory maxMint,\r\n        string memory mintPrice,\r\n        string memory reserve\r\n    ) public pure returns (string memory json, bytes memory jsonHex) {\r\n        string memory m2 = \u0027\",\"lim\":\"\u0027;\r\n        string memory m3 = \u0027\",\"maxMint\":\"\u0027;\r\n        string memory m4 = \u0027\",\"mintPrice\":\"\u0027;\r\n        string memory m5 = \u0027\",\"reserve\":\"\u0027;\r\n        string memory s = \u0027\"}\u0027;\r\n        bytes memory ss= abi.encodePacked(lim, m3, maxMint, m4, mintPrice, m5, reserve, s);\r\n        json = string(abi.encodePacked(p1, tick, m1, max, m2,ss));\r\n        jsonHex = bytes(json);\r\n    }\r\n\r\n    function transferFromData(\r\n        string memory tick,\r\n        string memory to,\r\n        string memory amt,\r\n         string memory from\r\n    ) public pure returns (string memory json, bytes memory jsonHex) {\r\n        string memory p = \u0027{\"p\":\"erc-20\",\"op\":\"transferFrom\",\"tick\":\"\u0027;\r\n        string memory m = \u0027\",\"amt\":\"\u0027;\r\n        string memory m2 = \u0027\", \"to\":\"\u0027;\r\n         string memory m3 = \u0027\", \"from\":\"\u0027;\r\n        string memory s = \u0027\"}\u0027;\r\n        json = string(abi.encodePacked(p, tick, m, amt, m2, to, m3, from, s));\r\n        jsonHex = bytes(json);\r\n    }\r\n    function approveData(\r\n        string memory tick,\r\n        string memory to,\r\n        string memory amt\r\n    ) public pure returns (string memory json, bytes memory jsonHex) {\r\n        string memory p = \u0027{\"p\":\"erc-20\",\"op\":\"approve\",\"tick\":\"\u0027;\r\n        string memory m = \u0027\",\"amt\":\"\u0027;\r\n        string memory m2 = \u0027\", \"to\":\"\u0027;\r\n        string memory s = \u0027\"}\u0027;\r\n        json = string(abi.encodePacked(p, tick, m, amt, m2, to, s));\r\n        jsonHex = bytes(json);\r\n    }\r\n}\r\n"},"Inscription.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\nimport \"./Counters.sol\";\r\nimport \"./JsmnSolLib.sol\";\r\nimport \"./inputData.sol\";\r\ncontract Inscription is inputData {\r\n    // Declare a public variable to store the owner\u0027s address\r\n    address public owner;\r\n\r\n    /**\r\n    * @dev Constructor that sets the contract deployer as the owner.\r\n    * \r\n    * The constructor is called only once when the contract is deployed.\r\n    * It assigns the address of the account that deploys the contract to the `owner` variable.\r\n    */\r\n    constructor() {\r\n        owner = msg.sender; // Set the owner to the address that deployed the contract\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier that restricts function access to the contract owner.\r\n    * \r\n    * This modifier checks if the caller of a function is the owner of the contract.\r\n    * If the caller is not the owner, it reverts the transaction with an error message.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Caller is not the contract owner\"); // Ensure the caller is the owner\r\n        _; // Placeholder for the function body to be executed\r\n    }\r\n\r\n    // Importing and using the Counters library for managing counters\r\n    using Counters for Counters.Counter;\r\n\r\n    // Define a constant for the number of decimal places for the token\r\n    uint256 constant DECIMALS = 18; // The standard decimal precision for ERC20 tokens is usually 18\r\n    bytes32 constant ERC20_P_HASH = keccak256(abi.encodePacked(\"p\"));\r\n    bytes32 constant ERC20_OP_HASH = keccak256(abi.encodePacked(\"op\"));\r\n    bytes32 constant ERC20_TICK_HASH = keccak256(abi.encodePacked(\"tick\"));\r\n    bytes32 constant ERC20_MAX_HASH = keccak256(abi.encodePacked(\"max\"));\r\n    bytes32 constant ERC20_LIM_HASH = keccak256(abi.encodePacked(\"lim\"));\r\n    bytes32 constant ERC20_AMT_HASH = keccak256(abi.encodePacked(\"amt\"));\r\n    bytes32 constant ERC20_P_HASH_ERC20 = keccak256(abi.encodePacked(\"erc-20\"));\r\n    bytes32 constant ERC20_OP_HASH_DEPLOY =keccak256(abi.encodePacked(\"deploy\"));\r\n    bytes32 constant ERC20_OP_HASH_MINT = keccak256(abi.encodePacked(\"mint\"));\r\n    bytes32 constant ERC20_OP_HASH_TRANSFER = keccak256(abi.encodePacked(\"transfer\"));\r\n    bytes32 constant ERC20_OP_HASH_TRANSFER_TO = keccak256(abi.encodePacked(\"to\"));\r\n    bytes32 constant ERC20_OP_HASH_TRANSFER_FROM = keccak256(abi.encodePacked(\"from\"));\r\n    bytes32 constant ERC20_MAX_MINT = keccak256(abi.encodePacked(\"maxMint\"));\r\n    bytes32 constant ERC20_MINT_PRICE = keccak256(abi.encodePacked(\"mintPrice\"));\r\n    bytes32 constant ERC20_RESERVE = keccak256(abi.encodePacked(\"reserve\"));\r\n    bytes32 constant ERC20_OP_HASH_APPROVE = keccak256(abi.encodePacked(\"approve\"));\r\n    bytes32 constant ERC20_OP_HASH_TRANSFERFROM = keccak256(abi.encodePacked(\"transferFrom\"));\r\n\r\n    // The ERC20Token struct represents basic information about an ERC20 token\r\n    struct ERC20Token {\r\n        string name;              // The name of the token\r\n        uint256 maxSupply;        // The maximum supply of the token, indicating the upper limit of tokens that can be minted\r\n        uint256 mintLimit;        // The limit per mint operation, i.e., the maximum number of tokens that can be minted in one transaction\r\n        uint256 minted;           // The total number of tokens that have already been minted\r\n        address deployer;         // The address of the deployer, representing the creator or owner of the contract\r\n        uint256 deployTime;       // The timestamp when the contract was deployed, indicating the deployment time of the token\r\n        uint256 holders;          // The number of addresses holding this token, representing the current number of token holders\r\n        uint256 maxMintPerAddress;// The maximum number of tokens that can be minted by a single address\r\n        uint256 mintPrice;        // The price per token mint in wei, representing the cost to mint one token\r\n        uint256 reserve;          // The reserve of tokens, representing the amount of tokens held in reserve or still available for minting\r\n    }\r\n\r\n    // The MintERC20 struct is used to track whether an ERC20 token has been deployed\r\n    struct MintERC20 {\r\n        string ticker;    // The symbol or ticker of the token\r\n        bool deployed;    // Whether the token has been deployed; true indicates the token is successfully deployed, false means not yet deployed\r\n    }\r\n\r\n    // A nested mapping to store token balances for each token ticker and address\r\n    // The first string represents the token ticker, \r\n    // and the address represents the user\u0027s wallet address.\r\n    mapping(string =\u003e mapping(address =\u003e uint256)) public balances; \r\n\r\n    // A nested mapping to track the number of tokens minted by each address for each token ticker\r\n    // The string represents the token ticker, and the address is the user\u0027s wallet address.\r\n    mapping(string =\u003e mapping(address =\u003e uint256)) public mintCounts; \r\n\r\n    // A mapping to link token tickers (converted to bytes32) to the MintERC20 struct\r\n    // It tracks deployed tokens and their ticker symbols.\r\n    mapping(bytes32 =\u003e MintERC20) private mintHexMap; \r\n\r\n    // A nested mapping to store allowances for token transfers between addresses\r\n    // The string represents the token ticker, the first address is the token owner,\r\n    // and the second address is the spender. The uint256 represents the allowance amount.\r\n    mapping(string =\u003e mapping(address =\u003e mapping(address =\u003e uint256))) public allowances; \r\n\r\n    // A mapping to store details of each token (inscription) by its ticker name\r\n    // The string is the token ticker, and the ERC20Token struct holds the token\u0027s information.\r\n    mapping(string =\u003e ERC20Token) public inscriptions; \r\n\r\n    // An array to store all token ticker names that have been created\r\n    string[] public tokenNames; \r\n\r\n    // A counter to track the total number of unique token tickers created\r\n    Counters.Counter public totalTickers;\r\n\r\n    function deployToken(\r\n        string memory ticker,                // Token ticker (e.g., \"ETH\", \"USDT\")\r\n        uint256 maxSupply,                   // Maximum total supply of the token\r\n        uint256 mintLimit,                   // Limit on how many tokens can be minted\r\n        uint256 maxMintPerAddress,           // Maximum tokens an address can mint\r\n        uint256 mintPrice,                   // Price per mint in wei\r\n        uint256 reserve                      // Amount of tokens reserved for the deployer\r\n    ) internal virtual {\r\n        // Ensure a minimum fee of 0.02 ether is paid for deploying a new token\r\n        require(msg.value \u003e= 0.02 ether, \"Insufficient deployment fee\");\r\n\r\n        // Retrieve or create a new ERC20Token struct for the provided ticker\r\n        ERC20Token storage newToken = inscriptions[ticker];\r\n\r\n        // Ensure the token doesn\u0027t already exist by checking if the deployer is address(0)\r\n        require(newToken.deployer == address(0), \"Token already exists\");\r\n\r\n        // Assign the provided parameters to the new token\u0027s properties\r\n        newToken.name = ticker;\r\n        newToken.maxSupply = maxSupply;\r\n        newToken.mintLimit = mintLimit;\r\n        newToken.deployer = msg.sender;             // The address deploying the token\r\n        newToken.deployTime = block.timestamp;      // Timestamp of token deployment\r\n        newToken.maxMintPerAddress = maxMintPerAddress;\r\n        newToken.mintPrice = mintPrice;\r\n        newToken.reserve = reserve;\r\n\r\n        // Increment the counter for the total number of tickers created\r\n        totalTickers.increment();\r\n\r\n        // Add the token ticker to the list of token names\r\n        tokenNames.push(ticker);\r\n\r\n        // Send the ether paid for the deployment to the contract owner\r\n        sendETH(payable(owner), msg.value);\r\n\r\n        // If a reserve is specified, allocate tokens to the deployer\u0027s balance\r\n        if (reserve != 0) {\r\n            balances[ticker][msg.sender] += reserve;    // Assign reserved tokens to the deployer\u0027s balance\r\n            newToken.minted += reserve;                 // Update the total number of minted tokens\r\n            newToken.holders += 1;                      // Increment the holder count\r\n        }\r\n    }\r\n\r\n    function inscribeMint(bytes32 mintHash) internal virtual {\r\n        // Retrieve the token\u0027s ticker using the provided mint hash\r\n        string memory ticker = mintHexMap[mintHash].ticker;\r\n\r\n        // Access the token details from the inscriptions mapping\r\n        ERC20Token storage token = inscriptions[ticker];\r\n\r\n        // Ensure the amount sent by the caller matches the mint price for the token\r\n        require(msg.value == token.mintPrice, \"Incorrect mint price\");\r\n\r\n        // If there is a maximum minting limit per address, ensure the user doesn\u0027t exceed it\r\n        if (token.maxMintPerAddress != 0) {\r\n            require(\r\n                mintCounts[ticker][msg.sender] + token.mintLimit \u003c= token.maxMintPerAddress,\r\n                \"Exceeds max mint per address\"\r\n            );\r\n        }\r\n        \r\n        // Ensure the total minted amount after this transaction won\u0027t exceed the max supply\r\n        require(\r\n            (token.minted + token.mintLimit) \u003c= token.maxSupply,\r\n            \"Exceeds available supply\"\r\n        );\r\n\r\n        // Update the total minted tokens count\r\n        token.minted += token.mintLimit;\r\n\r\n        // Double check that the minted tokens do not exceed the max supply\r\n        require(token.minted \u003c= token.maxSupply, \"Minting finished\");\r\n\r\n        // If this is the first time the caller is minting this token, increment the holders count\r\n        if (balances[ticker][msg.sender] == 0) {\r\n            token.holders += 1;\r\n        }\r\n\r\n        // Update the mint count and balance for the caller\r\n        mintCounts[ticker][msg.sender] += token.mintLimit;\r\n        balances[ticker][msg.sender] += token.mintLimit;\r\n\r\n        // Send 10% of the mint price to the contract owner\r\n        sendETH(payable(owner), calculatePercentage(msg.value, 10));\r\n\r\n        // Send 90% of the mint price to the token deployer\r\n        sendETH(payable(token.deployer), calculatePercentage(msg.value, 90));\r\n    }\r\n\r\n    function sendETH(address payable recipient, uint256 amount) private{\r\n        // Attempt to transfer the specified amount of ETH to the recipient\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n\r\n        // Revert the transaction if the transfer fails\r\n        require(success, \"ETH transfer failed\");\r\n    }\r\n\r\n    function calculatePercentage(uint256 amount, uint256 percentage) internal pure returns (uint256) {\r\n        // Calculate the percentage of the given amount\r\n        return (amount * percentage) / 100;\r\n    }\r\n\r\n    function transferTokens(\r\n        string memory ticker,  // The symbol of the token being transferred\r\n        address from,          // The address of the sender who is transferring the tokens\r\n        address to,            // The address of the recipient who will receive the tokens\r\n        uint256 amount         // The number of tokens to transfer\r\n    ) internal virtual {\r\n        // Retrieve the balance of the sender for the specified token\r\n        uint256 senderBalance = balances[ticker][from];\r\n\r\n        // Ensure the sender has enough balance to perform the transfer\r\n        require(senderBalance \u003e= amount, \"Insufficient balance for transfer\");\r\n\r\n        // Perform the transfer operation, subtracting the amount from the sender\u0027s balance\r\n        unchecked {\r\n            balances[ticker][from] = senderBalance - amount;\r\n        }\r\n\r\n        // If the sender\u0027s balance becomes zero after the transfer, reduce the holder count\r\n        if (balances[ticker][from] == 0) {\r\n            inscriptions[ticker].holders -= 1;\r\n        }\r\n\r\n        // If the recipient\u0027s balance was previously zero and a non-zero amount is transferred, increase the holder count\r\n        if (balances[ticker][to] == 0 \u0026\u0026 amount \u003e 0) {\r\n            inscriptions[ticker].holders += 1;\r\n        }\r\n\r\n        // Add the transferred amount to the recipient\u0027s balance\r\n        balances[ticker][to] += amount;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Approves a spender to transfer a specified amount of tokens on behalf of the token holder.\r\n    * \r\n    * @param ticker The symbol of the token being approved for spending (e.g., \"ETH\", \"USDT\").\r\n    * @param from The address of the token holder who is approving the transfer.\r\n    * @param to The address of the spender who is allowed to transfer the tokens.\r\n    * @param amount The maximum number of tokens the spender is allowed to transfer.\r\n    */\r\n    function approveTokens(\r\n        string memory ticker,  // The token symbol for which the approval is being made\r\n        address from,          // The address of the token owner who is giving approval\r\n        address to,            // The address of the spender who is receiving approval\r\n        uint256 amount         // The amount of tokens to approve for the spender\r\n    ) internal virtual {\r\n        // Set the approval amount in the allowances mapping\r\n        allowances[ticker][from][to] = amount;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers tokens from one address to another using the allowance mechanism.\r\n    * \r\n    * This function checks if the caller has enough allowance to transfer the specified amount of tokens\r\n    * from the `from` address to the `to` address.\r\n    * \r\n    * @param ticker The symbol of the token being transferred.\r\n    * @param from The address from which tokens will be transferred.\r\n    * @param to The address to which tokens will be transferred.\r\n    * @param amount The number of tokens to transfer from the `from` address to the `to` address.\r\n    */\r\n    function transferTokensFrom(\r\n        string memory ticker,  // The token symbol for the transfer operation\r\n        address from,          // The address from which tokens are being transferred\r\n        address to,            // The address to which tokens are being transferred\r\n        uint256 amount         // The amount of tokens to transfer\r\n    ) internal virtual {\r\n        // Check if the caller has sufficient allowance to perform the transfer\r\n        require(allowances[ticker][from][msg.sender] \u003e= 1, \"Insufficient allowance\");\r\n        \r\n        // Call the transferTokens function to execute the transfer\r\n        transferTokens(ticker, from, to, amount);\r\n    }\r\n\r\n\r\n   /**\r\n    * @dev Fallback function that handles incoming Ether and processes the input data.\r\n    * \r\n    * This function is triggered when the contract receives Ether and no function matches the call.\r\n    * It checks whether the minting process has been deployed for the given input, and if so,\r\n    * it allows only externally owned accounts (EOAs) to inscribe the mint. Otherwise, it calls the\r\n    * internal _inscribe function.\r\n    *\r\n    * @param input The calldata input data containing the minting information as a JSON string.\r\n    * @return An empty byte array.\r\n    */\r\n    fallback(bytes calldata input) external payable returns (bytes memory) {\r\n        // Convert the input data (bytes) into a string\r\n        string memory jsonString = string(input);\r\n        \r\n        // Calculate the hash of the JSON string to identify the mint\r\n        bytes32 mintHash = keccak256(abi.encodePacked(jsonString));\r\n        \r\n        // Check if the minting process has been deployed\r\n        if (mintHexMap[mintHash].deployed) {\r\n            // Ensure that the caller is an externally owned account (EOA)\r\n            require(msg.sender == tx.origin, \"Only EOA allowed\");\r\n            \r\n            // Call the inscribeMint function to process the minting\r\n            inscribeMint(mintHash);\r\n        } else {\r\n            // If not deployed, call the internal _inscribe function\r\n            _inscribe(jsonString);\r\n        }\r\n        \r\n        // Return an empty byte array\r\n        return \"\";\r\n    }\r\n\r\n\r\n   function _inscribe(string memory jsonStr) internal virtual {\r\n        uint256 returnValue;\r\n        JsmnSolLib.Token[] memory tokens;\r\n        (returnValue, tokens, ) = JsmnSolLib.parse(jsonStr, 17);\r\n        require(returnValue == JsmnSolLib.RETURN_SUCCESS, \"JSON parsing failed\");\r\n\r\n        {\r\n        string memory p = JsmnSolLib.getBytes(\r\n            jsonStr,\r\n            tokens[1].start,\r\n            tokens[1].end\r\n        );\r\n        string memory pVal = JsmnSolLib.getBytes(\r\n            jsonStr,\r\n            tokens[2].start,\r\n            tokens[2].end\r\n        );\r\n\r\n        string memory op = JsmnSolLib.getBytes(\r\n            jsonStr,\r\n            tokens[3].start,\r\n            tokens[3].end\r\n        );\r\n        string memory tick = JsmnSolLib.getBytes(\r\n            jsonStr,\r\n            tokens[5].start,\r\n            tokens[5].end\r\n        );\r\n        require(\r\n            keccak256(abi.encodePacked(p)) == ERC20_P_HASH \u0026\u0026\r\n                keccak256(abi.encodePacked(pVal)) == ERC20_P_HASH_ERC20 \u0026\u0026\r\n                keccak256(abi.encodePacked(op)) == ERC20_OP_HASH \u0026\u0026\r\n                keccak256(abi.encodePacked(tick)) == ERC20_TICK_HASH,\r\n            \"Invalid ERC-20 parameters\"\r\n        );\r\n        \r\n        }\r\n\r\n        string memory opVal = JsmnSolLib.getBytes(\r\n            jsonStr,\r\n            tokens[4].start,\r\n            tokens[4].end\r\n        );\r\n        string memory tickVal = JsmnSolLib.getBytes(\r\n            jsonStr,\r\n            tokens[6].start,\r\n            tokens[6].end\r\n        );\r\n        if (keccak256(abi.encodePacked(opVal)) == ERC20_OP_HASH_TRANSFER) {\r\n            string memory amt = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[7].start,\r\n                tokens[7].end\r\n            );\r\n            string memory toKey = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[9].start,\r\n                tokens[9].end\r\n            );\r\n            require(\r\n                keccak256(abi.encodePacked(toKey)) ==\r\n                    ERC20_OP_HASH_TRANSFER_TO \u0026\u0026\r\n                    keccak256(abi.encodePacked(amt)) == ERC20_AMT_HASH,\r\n                \"Invalid transfer parameters\"\r\n            );\r\n            string memory amtVal = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[8].start,\r\n                tokens[8].end\r\n            );\r\n            string memory toVal = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[10].start,\r\n                tokens[10].end\r\n            );\r\n            transferTokens(\r\n                tickVal,\r\n                msg.sender,\r\n                JsmnSolLib.stringToAddress(toVal),\r\n                uint256(JsmnSolLib.parseInt(amtVal, DECIMALS))\r\n            );\r\n\r\n        } else if (keccak256(abi.encodePacked(opVal)) == ERC20_OP_HASH_DEPLOY) {\r\n            string memory max = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[7].start,\r\n                tokens[7].end\r\n            );\r\n\r\n            string memory lim = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[9].start,\r\n                tokens[9].end\r\n            );\r\n\r\n            string memory maxMint = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[11].start,\r\n                tokens[11].end\r\n            );\r\n\r\n            string memory mintPrice = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[13].start,\r\n                tokens[13].end\r\n            );\r\n\r\n            string memory reserve = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[15].start,\r\n                tokens[15].end\r\n            );\r\n\r\n            require(\r\n                keccak256(abi.encodePacked(max)) == ERC20_MAX_HASH \u0026\u0026\r\n                    keccak256(abi.encodePacked(lim)) == ERC20_LIM_HASH \u0026\u0026\r\n                    keccak256(abi.encodePacked(maxMint)) == ERC20_MAX_MINT \u0026\u0026\r\n                        keccak256(abi.encodePacked(mintPrice)) == ERC20_MINT_PRICE \u0026\u0026\r\n                            keccak256(abi.encodePacked(reserve)) == ERC20_RESERVE,\r\n                \"Invalid deployment parameters\"\r\n            );\r\n\r\n            string memory maxVal = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[8].start,\r\n                tokens[8].end\r\n            );\r\n            string memory limVal = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[10].start,\r\n                tokens[10].end\r\n            );\r\n            string memory mintVal = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[12].start,\r\n                tokens[12].end\r\n            );\r\n            string memory priceVal = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[14].start,\r\n                tokens[14].end\r\n            );\r\n            string memory reserveVal = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[16].start,\r\n                tokens[16].end\r\n            );\r\n            MintERC20 storage mintercData = mintHexMap[ keccak256(abi.encodePacked(mintString(tickVal,limVal)))];\r\n            mintercData.deployed = true;\r\n            mintercData.ticker = tickVal;\r\n            deployToken(\r\n                tickVal,\r\n                uint256(JsmnSolLib.parseInt(maxVal, DECIMALS)),\r\n                uint256(JsmnSolLib.parseInt(limVal, DECIMALS)),\r\n                uint256(JsmnSolLib.parseInt(mintVal, DECIMALS)),\r\n                uint256(JsmnSolLib.parseInt(priceVal, DECIMALS)),\r\n                uint256(JsmnSolLib.parseInt(reserveVal, DECIMALS))\r\n            );\r\n        } else if (keccak256(abi.encodePacked(opVal)) == ERC20_OP_HASH_APPROVE) {\r\n            string memory amt = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[7].start,\r\n                tokens[7].end\r\n            );\r\n            string memory toKey = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[9].start,\r\n                tokens[9].end\r\n            );\r\n            require(\r\n                keccak256(abi.encodePacked(toKey)) ==\r\n                    ERC20_OP_HASH_TRANSFER_TO \u0026\u0026\r\n                    keccak256(abi.encodePacked(amt)) == ERC20_AMT_HASH,\r\n                \"Invalid approval parameters\"\r\n            );\r\n            string memory amtVal = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[8].start,\r\n                tokens[8].end\r\n            );\r\n            string memory toVal = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[10].start,\r\n                tokens[10].end\r\n            );\r\n            approveTokens(\r\n                tickVal,\r\n                msg.sender,\r\n                JsmnSolLib.stringToAddress(toVal),\r\n                uint256(JsmnSolLib.parseInt(amtVal))\r\n            );\r\n        } else if (keccak256(abi.encodePacked(opVal)) == ERC20_OP_HASH_TRANSFERFROM) {\r\n            string memory amt = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[7].start,\r\n                tokens[7].end\r\n            );\r\n            string memory toKey = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[9].start,\r\n                tokens[9].end\r\n            );\r\n            string memory fromKey = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[11].start,\r\n                tokens[11].end\r\n            );\r\n            require(\r\n                keccak256(abi.encodePacked(toKey)) == ERC20_OP_HASH_TRANSFER_TO \u0026\u0026\r\n                keccak256(abi.encodePacked(amt)) == ERC20_AMT_HASH \u0026\u0026\r\n                keccak256(abi.encodePacked(fromKey)) == ERC20_OP_HASH_TRANSFER_FROM,\r\n                \"Invalid transferFrom parameters\"\r\n            );\r\n            string memory amtVal = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[8].start,\r\n                tokens[8].end\r\n            );\r\n            string memory toVal = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[10].start,\r\n                tokens[10].end\r\n            );\r\n            string memory fromVal = JsmnSolLib.getBytes(\r\n                jsonStr,\r\n                tokens[12].start,\r\n                tokens[12].end\r\n            );\r\n\r\n            transferTokensFrom(\r\n                tickVal,\r\n                JsmnSolLib.stringToAddress(fromVal),\r\n                JsmnSolLib.stringToAddress(toVal),\r\n                uint256(JsmnSolLib.parseInt(amtVal, DECIMALS))\r\n            );\r\n        } \r\n    }\r\n\r\n    function withdrawETH(address payable _to, uint _amount) external onlyOwner{\r\n        _to.transfer(_amount);\r\n    }\r\n\r\n     function withdrawERC20(address token, address to, uint256 value) external onlyOwner{\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027TransferHelper: TRANSFER_FAILED\u0027);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n}\r\n"},"JsmnSolLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/*\nCopyright (c) 2017 Christoph Niemann\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\npragma solidity ^0.8.1;\n\nlibrary JsmnSolLib {\n    enum JsmnType {\n        UNDEFINED,\n        OBJECT,\n        ARRAY,\n        STRING,\n        PRIMITIVE\n    }\n\n    uint256 constant RETURN_SUCCESS = 0;\n    uint256 constant RETURN_ERROR_INVALID_JSON = 1;\n    uint256 constant RETURN_ERROR_PART = 2;\n    uint256 constant RETURN_ERROR_NO_MEM = 3;\n\n    struct Token {\n        JsmnType jsmnType;\n        uint256 start;\n        bool startSet;\n        uint256 end;\n        bool endSet;\n        uint8 size;\n    }\n\n    struct Parser {\n        uint256 pos;\n        uint256 toknext;\n        int256 toksuper;\n    }\n\n    function init(uint256 length)\n        internal\n        pure\n        returns (Parser memory, Token[] memory)\n    {\n        Parser memory p = Parser(0, 0, -1);\n        Token[] memory t = new Token[](length);\n        return (p, t);\n    }\n\n    function allocateToken(Parser memory parser, Token[] memory tokens)\n        internal\n        pure\n        returns (bool, Token memory)\n    {\n        if (parser.toknext \u003e= tokens.length) {\n            // no more space in tokens\n            return (false, tokens[tokens.length - 1]);\n        }\n        Token memory token = Token(JsmnType.UNDEFINED, 0, false, 0, false, 0);\n        tokens[parser.toknext] = token;\n        parser.toknext++;\n        return (true, token);\n    }\n\n    function fillToken(\n        Token memory token,\n        JsmnType jsmnType,\n        uint256 start,\n        uint256 end\n    ) internal pure {\n        token.jsmnType = jsmnType;\n        token.start = start;\n        token.startSet = true;\n        token.end = end;\n        token.endSet = true;\n        token.size = 0;\n    }\n\n    function parseString(\n        Parser memory parser,\n        Token[] memory tokens,\n        bytes memory s\n    ) internal pure returns (uint256) {\n        uint256 start = parser.pos;\n        bool success;\n        Token memory token;\n        parser.pos++;\n\n        for (; parser.pos \u003c s.length; parser.pos++) {\n            bytes1 c = s[parser.pos];\n\n            // Quote -\u003e end of string\n            if (c == \u0027\"\u0027) {\n                (success, token) = allocateToken(parser, tokens);\n                if (!success) {\n                    parser.pos = start;\n                    return RETURN_ERROR_NO_MEM;\n                }\n                fillToken(token, JsmnType.STRING, start + 1, parser.pos);\n                return RETURN_SUCCESS;\n            }\n\n            if (uint8(c) == 92 \u0026\u0026 parser.pos + 1 \u003c s.length) {\n                // handle escaped characters: skip over it\n                parser.pos++;\n                if (\n                    s[parser.pos] == \u0027\"\u0027 ||\n                    s[parser.pos] == \"/\" ||\n                    s[parser.pos] == \"\\\\\" ||\n                    s[parser.pos] == \"f\" ||\n                    s[parser.pos] == \"r\" ||\n                    s[parser.pos] == \"n\" ||\n                    s[parser.pos] == \"b\" ||\n                    s[parser.pos] == \"t\"\n                ) {\n                    continue;\n                } else {\n                    // all other values are INVALID\n                    parser.pos = start;\n                    return (RETURN_ERROR_INVALID_JSON);\n                }\n            }\n        }\n        parser.pos = start;\n        return RETURN_ERROR_PART;\n    }\n\n    function parsePrimitive(\n        Parser memory parser,\n        Token[] memory tokens,\n        bytes memory s\n    ) internal pure returns (uint256) {\n        bool found = false;\n        uint256 start = parser.pos;\n        bytes1 c;\n        bool success;\n        Token memory token;\n        for (; parser.pos \u003c s.length; parser.pos++) {\n            c = s[parser.pos];\n            if (\n                c == \" \" ||\n                c == \"\\t\" ||\n                c == \"\\n\" ||\n                c == \"\\r\" ||\n                c == \",\" ||\n                c == 0x7d ||\n                c == 0x5d\n            ) {\n                found = true;\n                break;\n            }\n            if (uint8(c) \u003c 32 || uint8(c) \u003e 127) {\n                parser.pos = start;\n                return RETURN_ERROR_INVALID_JSON;\n            }\n        }\n        if (!found) {\n            parser.pos = start;\n            return RETURN_ERROR_PART;\n        }\n\n        // found the end\n        (success, token) = allocateToken(parser, tokens);\n        if (!success) {\n            parser.pos = start;\n            return RETURN_ERROR_NO_MEM;\n        }\n        fillToken(token, JsmnType.PRIMITIVE, start, parser.pos);\n        parser.pos--;\n        return RETURN_SUCCESS;\n    }\n\n    function parse(string memory json, uint256 numberElements)\n        internal\n        pure\n        returns (\n            uint256,\n            Token[] memory tokens,\n            uint256\n        )\n    {\n        bytes memory s = bytes(json);\n        bool success;\n        Parser memory parser;\n        (parser, tokens) = init(numberElements);\n\n        // Token memory token;\n        uint256 r;\n        uint256 count = parser.toknext;\n        uint256 i;\n        Token memory token;\n\n        for (; parser.pos \u003c s.length; parser.pos++) {\n            bytes1 c = s[parser.pos];\n\n            // 0x7b, 0x5b opening curly parentheses or brackets\n            if (c == 0x7b || c == 0x5b) {\n                count++;\n                (success, token) = allocateToken(parser, tokens);\n                if (!success) {\n                    return (RETURN_ERROR_NO_MEM, tokens, 0);\n                }\n                if (parser.toksuper != -1) {\n                    tokens[uint256(parser.toksuper)].size++;\n                }\n                token.jsmnType = (c == 0x7b ? JsmnType.OBJECT : JsmnType.ARRAY);\n                token.start = parser.pos;\n                token.startSet = true;\n                parser.toksuper = int256(parser.toknext - 1);\n                continue;\n            }\n\n            // closing curly parentheses or brackets\n            if (c == 0x7d || c == 0x5d) {\n                JsmnType tokenType = (\n                    c == 0x7d ? JsmnType.OBJECT : JsmnType.ARRAY\n                );\n                bool isUpdated = false;\n                for (i = parser.toknext - 1; i \u003e= 0; i--) {\n                    token = tokens[i];\n                    if (token.startSet \u0026\u0026 !token.endSet) {\n                        if (token.jsmnType != tokenType) {\n                            // found a token that hasn\u0027t been closed but from a different type\n                            return (RETURN_ERROR_INVALID_JSON, tokens, 0);\n                        }\n                        parser.toksuper = -1;\n                        tokens[i].end = parser.pos + 1;\n                        tokens[i].endSet = true;\n                        isUpdated = true;\n                        break;\n                    }\n                }\n                if (!isUpdated) {\n                    return (RETURN_ERROR_INVALID_JSON, tokens, 0);\n                }\n                for (; i \u003e 0; i--) {\n                    token = tokens[i];\n                    if (token.startSet \u0026\u0026 !token.endSet) {\n                        parser.toksuper = int256(i);\n                        break;\n                    }\n                }\n\n                if (i == 0) {\n                    token = tokens[i];\n                    if (token.startSet \u0026\u0026 !token.endSet) {\n                        parser.toksuper = int128(uint128(i));\n                    }\n                }\n                continue;\n            }\n\n            // 0x42\n            if (c == \u0027\"\u0027) {\n                r = parseString(parser, tokens, s);\n\n                if (r != RETURN_SUCCESS) {\n                    return (r, tokens, 0);\n                }\n                //JsmnError.INVALID;\n                count++;\n                if (parser.toksuper != -1)\n                    tokens[uint256(parser.toksuper)].size++;\n                continue;\n            }\n\n            // \u0027 \u0027, \\r, \\t, \\n\n            if (c == \" \" || c == 0x11 || c == 0x12 || c == 0x14) {\n                continue;\n            }\n\n            // 0x3a\n            if (c == \":\") {\n                parser.toksuper = int256(parser.toknext - 1);\n                continue;\n            }\n\n            if (c == \",\") {\n                if (\n                    parser.toksuper != -1 \u0026\u0026\n                    tokens[uint256(parser.toksuper)].jsmnType !=\n                    JsmnType.ARRAY \u0026\u0026\n                    tokens[uint256(parser.toksuper)].jsmnType != JsmnType.OBJECT\n                ) {\n                    for (i = parser.toknext - 1; i \u003e= 0; i--) {\n                        if (\n                            tokens[i].jsmnType == JsmnType.ARRAY ||\n                            tokens[i].jsmnType == JsmnType.OBJECT\n                        ) {\n                            if (tokens[i].startSet \u0026\u0026 !tokens[i].endSet) {\n                                parser.toksuper = int256(i);\n                                break;\n                            }\n                        }\n                    }\n                }\n                continue;\n            }\n\n            // Primitive\n            if (\n                (c \u003e= \"0\" \u0026\u0026 c \u003c= \"9\") ||\n                c == \"-\" ||\n                c == \"f\" ||\n                c == \"t\" ||\n                c == \"n\"\n            ) {\n                if (parser.toksuper != -1) {\n                    token = tokens[uint256(parser.toksuper)];\n                    if (\n                        token.jsmnType == JsmnType.OBJECT ||\n                        (token.jsmnType == JsmnType.STRING \u0026\u0026 token.size != 0)\n                    ) {\n                        return (RETURN_ERROR_INVALID_JSON, tokens, 0);\n                    }\n                }\n\n                r = parsePrimitive(parser, tokens, s);\n                if (r != RETURN_SUCCESS) {\n                    return (r, tokens, 0);\n                }\n                count++;\n                if (parser.toksuper != -1) {\n                    tokens[uint256(parser.toksuper)].size++;\n                }\n                continue;\n            }\n\n            // printable char\n            if (c \u003e= 0x20 \u0026\u0026 c \u003c= 0x7e) {\n                return (RETURN_ERROR_INVALID_JSON, tokens, 0);\n            }\n        }\n\n        return (RETURN_SUCCESS, tokens, parser.toknext);\n    }\n\n    function getBytes(\n        string memory json,\n        uint256 start,\n        uint256 end\n    ) internal pure returns (string memory) {\n        bytes memory s = bytes(json);\n        bytes memory result = new bytes(end - start);\n        for (uint256 i = start; i \u003c end; i++) {\n            result[i - start] = s[i];\n        }\n        return string(result);\n    }\n\n    // parseInt\n    function parseInt(string memory _a) internal pure returns (int256) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string memory _a, uint256 _b)\n        internal\n        pure\n        returns (int256)\n    {\n        bytes memory bresult = bytes(_a);\n        int256 mint = 0;\n        bool decimals = false;\n        bool negative = false;\n        for (uint256 i = 0; i \u003c bresult.length; i++) {\n            if ((i == 0) \u0026\u0026 (bresult[i] == \"-\")) {\n                negative = true;\n            }\n            if ((uint8(bresult[i]) \u003e= 48) \u0026\u0026 (uint8(bresult[i]) \u003c= 57)) {\n                if (decimals) {\n                    if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += int256(uint256(uint8(bresult[i]) - 48));\n            } else if (uint8(bresult[i]) == 46) decimals = true;\n        }\n        if (_b \u003e 0) mint *= int256(10**_b);\n        if (negative) mint *= -1;\n        return mint;\n    }\n\n    function uint2str(uint256 i) internal pure returns (string memory) {\n        if (i == 0) return \"0\";\n        uint256 j = i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len - 1;\n        while (i != 0) {\n            bstr[k--] = bytes1(uint8(48 + (i % 10)));\n            i /= 10;\n        }\n        return string(bstr);\n    }\n\n    function parseBool(string memory _a) internal pure returns (bool) {\n        if (strCompare(_a, \"true\") == 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function strCompare(string memory _a, string memory _b)\n        internal\n        pure\n        returns (int256)\n    {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint256 minLength = a.length;\n        if (b.length \u003c minLength) minLength = b.length;\n        for (uint256 i = 0; i \u003c minLength; i++)\n            if (a[i] \u003c b[i]) return -1;\n            else if (a[i] \u003e b[i]) return 1;\n        if (a.length \u003c b.length) return -1;\n        else if (a.length \u003e b.length) return 1;\n        else return 0;\n    }\n\n    function addressToString(address addr)\n        internal\n        pure\n        returns (string memory)\n    {\n        //Convert addr to bytes\n        bytes20 value = bytes20(uint160(addr));\n        bytes memory strBytes = new bytes(42);\n        //Encode hex prefix\n        strBytes[0] = \"0\";\n        strBytes[1] = \"x\";\n        //Encode bytes usig hex encoding\n        for (uint256 i = 0; i \u003c 20; i++) {\n            uint8 byteValue = uint8(value[i]);\n            strBytes[2 + (i \u003c\u003c 1)] = encode((byteValue \u003e\u003e 4) \u0026 0x0f);\n            strBytes[3 + (i \u003c\u003c 1)] = encode(byteValue \u0026 0x0f);\n        }\n        return string(strBytes);\n    }\n\n    function stringToAddress(string memory data)\n        internal\n        pure\n        returns (address)\n    {\n        bytes memory strBytes = bytes(data);\n        require(\n            strBytes.length \u003e= 39 \u0026\u0026 strBytes.length \u003c= 42,\n            \"Not hex string\"\n        );\n        //Skip prefix\n        uint256 start = 0;\n        uint256 bytesBegin = 0;\n        if (strBytes[1] == \"x\" || strBytes[1] == \"X\") {\n            start = 2;\n        }\n        //Special case: 0xabc. should be 0x0abc\n        uint160 addrValue = 0;\n        uint256 effectPayloadLen = strBytes.length - start;\n        if (effectPayloadLen == 39) {\n            addrValue += decode(strBytes[start++]);\n            bytesBegin++;\n        }\n        //Main loop\n        for (uint256 i = bytesBegin; i \u003c 20; i++) {\n            addrValue \u003c\u003c= 8;\n            uint8 tmp1 = decode(strBytes[start]);\n            uint8 tmp2 = decode(strBytes[start + 1]);\n            uint8 combined = (tmp1 \u003c\u003c 4) + tmp2;\n            addrValue += combined;\n            start += 2;\n        }\n\n        return address(addrValue);\n    }\n\n    function decode(bytes1 asc) private pure returns (uint8) {\n        uint8 val = uint8(asc);\n        //0-9\n        if (val \u003e= 48 \u0026\u0026 val \u003c= 57) {\n            return val - 48;\n        }\n        //A-F\n        if (val \u003e= 65 \u0026\u0026 val \u003c= 70) {\n            return val - 55;\n        }\n        //a-f\n        return val - 87;\n    }\n\n    function encode(uint8 num) private pure returns (bytes1) {\n        //0-9 -\u003e 0-9\n        if (num \u003e= 0 \u0026\u0026 num \u003c= 9) {\n            return bytes1(num + 48);\n        }\n        //10-15 -\u003e a-f\n        return bytes1(num + 87);\n    }\n}\n"}}