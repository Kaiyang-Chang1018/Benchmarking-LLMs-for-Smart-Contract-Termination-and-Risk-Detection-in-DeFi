// SPDX-License-Identifier: MIT

        /**

        ⡖⠒⠒⣆⠀⣰⠲⠦⡄⠀⢀⡤⢤⣀⡀⠀⣀⡴⠖⠒⠒⠒⢒⡄⠀⠀⠀⢀⣀⣀⡀⣀⣠⠤⡀⣠⠤⠤⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀
        ⣧⠂⡐⣹⢶⣯⠀⢰⡇⠀⡼⢁⠠⠀⣧⠀⡇⠄⠂⣬⣤⣥⣦⣿⡟⠉⡉⠉⡀⢡⡿⣇⠠⢈⢻⠃⡐⣼⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀
        ⢳⠠⠐⡈⢀⠃⠌⣼⢁⡼⠃⡀⣶⠁⠸⣷⠓⡈⢤⣿⣋⠉⠃⢿⣧⠀⠰⠷⠻⢻⠀⠈⢷⣀⠂⡐⣰⠏
        ⢸⡇⠄⡁⣆⠈⢤⡟⡾⠁⣐⣄⣠⡈⠄⢿⣔⠠⢈⠛⠿⠧⢈⢸⣿⠀⠱⡦⠶⠿⢖⡆⠈⡇⠐⠰⡏⠀
        ⠀⠧⠴⠴⠿⠦⠼⠁⠉⠙⠚⠁⠉⠧⠴⠬⠟⠳⠤⠦⠴⠤⠦⠞⠹⠥⠦⠴⠬⠴⠼⠃⠀⠧⠥⠦⠇
        ---The first 8bit Wagering Platform on ETH--- 

        * Website: https://home.wagey.gg/
        * Flappy Pepe V1.0: https://wagey.gg/game/
        * Litepaper V1.0: https://litepaper.wagey.gg/
        * Telegram: https://t.me/wageygg/
        * Twitter: https://twitter.com/wageygg/
        * X: https://twitter.com/wageygg/

        ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⠿⢿⣿⡿⠿⠿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
        ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⢀⣀⡶⡶⣶⣲⣀⠁⣀⣶⢶⣆⡀⠛⢿⣯⣿⣿⣿⣼⣿⣿⣿
        ⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⢁⣴⣞⠯⠁⠉⡀⠉⠈⠆⠈⢿⠾⠍⠁⠂⠀⠑⢿⡷⣿⢾⡿⣽⣿
        ⣿⣿⣿⣿⣿⣿⣿⣿⣿⠋⣀⡿⣞⣉⣰⡟⣿⡽⣻⡟⣶⢲⣎⠐⢶⣻⣟⢿⣲⡈⠕⣿⢾⣿⢿⣿
        ⣿⣿⣿⣿⣿⣿⣿⣿⠛⣠⢿⣝⣯⢟⡧⠃⣤⢤⡤⣤⢤⡤⡜⢳⠀⡓⠃⣤⢤⡤⡔⠛⢻⣿⣿⣿
        ⣿⣿⣿⣿⣿⣿⣿⠏⢠⣯⣟⡾⣭⣟⡤⢁⡤⢄⠀⣀⠀⢤⣌⡀⢨⢡⡴⢄⠀⣀⠤⡄⢹⣿⣿⣿
        ⣿⣿⣿⣿⣿⣿⡇⢰⣞⡾⣞⡽⣳⢏⡷⣆⡁⠈⠀⣍⠀⢸⡟⢁⣲⢎⡁⠈⠀⣉⠈⠇⣸⣯⣿⣿
        ⣿⣿⣿⣿⣿⠇⢀⡾⣽⢾⣍⠁⣤⠤⠼⢯⡷⣯⣤⡤⡤⠄⢸⣯⠧⠄⠱⠦⠤⠤⠄⠠⢿⣿⣽⣿
        ⣿⣿⣿⣿⣿⠀⡿⣽⣛⡾⣽⣻⡍⠀⠀⠉⠁⢻⣞⣉⣁⢶⣻⣞⡷⣆⡑⠒⢲⣖⡖⠃⠈⢿⣿⣿
        ⣿⣿⣿⣿⣿⠀⣟⡷⣯⢟⣳⡽⣶⢦⠀⠀⠂⠀⠀⠀⠀⠋⠓⠚⠙⠋⠓⠛⠚⠃⠀⠀⠀⢼⣿⣿
        ⣿⣿⣿⣿⣿⡄⠉⣷⢯⣟⡷⣻⣭⢿⡽⣄⡀⠠⢀⣀⣁⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⢿⣿
        ⣿⣿⣿⣿⣿⣇⡀⢻⢯⡾⣽⣳⢯⣻⠎⣁⡤⣲⠼⠿⠿⠿⢷⣶⣤⡀⢀⣀⣠⠀⢀⣶⣻⣟⣿⣿
        ⣿⣿⣿⣿⣿⣿⡇⢨⣟⡷⣯⣽⡳⠏⣸⣭⡞⠅⠞⡿⠿⣿⠗⣾⣹⡿⠇⣠⣤⠀⠙⣿⣻⣏⣿⣿
        ⣿⣿⣿⣿⣿⡟⠇⣸⠾⣝⣷⡳⡏⢀⣷⢛⣰⢰⡇⢰⡇⠀⣾⠈⠋⣁⡾⠓⠋⣿⢆⡉⠹⣯⣽⣿
        ⣿⣿⣿⣿⣟⠁⣤⣟⠿⣽⣞⣽⡃⢸⣿⢸⣷⠸⡧⡼⢧⣤⠿⠀⢄⠋⢡⡄⠀⣤⠯⢿⣥⠈⠹⣿
        ⣿⣿⣿⠛⢉⣤⣟⡾⣻⠷⣞⣳⢧⠘⣿⣼⣻⣧⠘⠎⠁⠒⠁⣸⡟⣿⣿⠃⠸⠏⣁⡤⢋⣹⠄⢨
        ⣿⡟⢂⣰⣾⣳⢯⡽⣏⡿⣽⣫⣞⣦⠹⣿⣧⣻⢷⣤⣴⣤⣴⣛⣼⡽⠇⣠⣶⣀⡀⠐⠚⢀⡄⢸
        ⡏⠁⣼⣻⢶⡯⣟⡽⣯⣽⡳⣟⣞⡷⣳⣄⠛⠿⢿⣿⣿⣿⡿⠽⢏⡀⠘⠿⢞⣽⣻⡽⣯⣟⠁⣼
        ⠃⣠⢿⣭⢷⣻⡽⣽⠾⣵⣻⡝⠺⣽⣳⢯⡷⣶⣤⡤⣤⢤⣤⢶⡞⠃⣠⣶⣺⡞⣷⣻⡵⠈⢠⣿
        ⠀⣟⣯⣞⣯⢷⣻⣭⡟⡷⢯⣞⡅⠰⣯⠿⣽⠾⣵⣻⡽⣛⣾⣻⠒⣤⣟⡾⣵⣻⣗⡯⠆⢸⣿⣿
        ⣶⣿⣾⣷⣿⣿⣷⣷⣿⣿⣿⣾⣷⣾⣿⣿⣿⣿⣷⣿⣿⣿⣾⣷⣶⣾⣷⣿⣷⣿⣾⣷⣼⣿⣿⣿
        
        */

        pragma solidity ^0.8.19;

        abstract contract Ownable {
            address private _owner;
            event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

            constructor() {
                _transferOwnership(msg.sender);
            }

            modifier onlyOwner() {
                _checkOwner();
                _;
                }

            function owner() public view virtual returns (address) {
                return _owner;
            }

            function _checkOwner() internal view virtual {
                require(owner() == msg.sender, "Ownable: caller is not the owner");
            }

            function renounceOwnership() public virtual onlyOwner {
                _transferOwnership(address(0));
            }

            function transferOwnership(address newOwner) public virtual onlyOwner {
                require(newOwner != address(0), "Ownable: new owner is the zero address");
                _transferOwnership(newOwner);
            }

            function _transferOwnership(address newOwner) internal virtual {
                address oldOwner = _owner;
                _owner = newOwner;
                emit OwnershipTransferred(oldOwner, newOwner);
            }
        }

        interface IERC20 {
            event Transfer(address indexed from, address indexed to, uint256 value);
            event Approval(address indexed owner, address indexed spender, uint256 value);

            function totalSupply() external view returns (uint256);
            function balanceOf(address account) external view returns (uint256);
            function transfer(address to, uint256 amount) external returns (bool);
            function allowance(address owner, address spender) external view returns (uint256);
            function approve(address spender, uint256 amount) external returns (bool);
            function transferFrom(address from, address to, uint256 amount) external returns (bool);
        }

        contract WAGEYGG is IERC20, Ownable {
            
            string private _name = "WAGEY GG";
            string private _symbol = "WAGEY";
            uint8 private _decimals = 18;
            uint256 private _totalSupply = 5000000 * (10 ** decimals());

            mapping(address => uint256) private _balances;
            mapping(address => mapping(address => uint256)) private _allowances;

            uint256 public buyFee = 2; // 2% buy fee
            uint256 public sellFee = 2; // 2% sell fee
            address public feeCollector; // Address to collect the fees

            uint256 private constant _uniqueID = 1;

            constructor (address _feeCollector) {
                require(_feeCollector != address(0), "Fee collector address cannot be zero");
                feeCollector = _feeCollector; // Set the specified address as the fee collector
                _balances[owner()] = _totalSupply;
                emit Transfer(address(0), owner(), _totalSupply);
            }

            function name() public view virtual returns (string memory) {
                return _name;
            }

            function symbol() public view virtual returns (string memory) {
                return _symbol;
            }

            function decimals() public view virtual returns (uint8) {
                return _decimals;
            }

            function totalSupply() public view virtual override returns (uint256) {
                return _totalSupply;
            }

            function balanceOf(address account) public view virtual override returns (uint256) {
                return _balances[account];
            }

            function transfer(address to, uint256 amount) public virtual override returns (bool) {
                address owner = msg.sender;
                _transfer(owner, to, amount);
                return true;
            }

            function allowance(address owner, address spender) public view virtual override returns (uint256) {
                return _allowances[owner][spender];
            }

            function approve(address spender, uint256 amount) public virtual override returns (bool) {
                address owner = msg.sender;
                _approve(owner, spender, amount);
                return true;
            }

            function transferFrom(
                address from,
                address to,
                uint256 amount
            ) public virtual override returns (bool) {
                address spender = msg.sender;
                _spendAllowance(from, spender, amount);
                _transfer(from, to, amount);
                return true;
            }

            function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
                address owner = msg.sender;
                _approve(owner, spender, allowance(owner, spender) + addedValue);
                return true;
            }

            function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
                address owner = msg.sender;
                uint256 currentAllowance = allowance(owner, spender);
                require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
                unchecked {
                    _approve(owner, spender, currentAllowance - subtractedValue);
                }
                return true;
            }

            function setFeeCollector(address newCollector) external onlyOwner {
                require(newCollector != address(0), "Fee collector address cannot be zero");
                feeCollector = newCollector;
            }

            function setBuyFee(uint256 newBuyFee) external onlyOwner {
                require(newBuyFee <= 100, "Fee too high");
                buyFee = newBuyFee;
            }

            function setSellFee(uint256 newSellFee) external onlyOwner {
                require(newSellFee <= 100, "Fee too high");
                sellFee = newSellFee;
            }

            function _transfer(
                address from,
                address to,
                uint256 amount
            ) internal virtual {
                require(from != address(0), "ERC20: transfer from the zero address");
                require(to != address(0), "ERC20: transfer to the zero address");

                uint256 feeAmount = 0;

                // Apply 1% fee for buys (if `to` is not the feeCollector)
                if (from != feeCollector && to != feeCollector) {
                    feeAmount = (amount * buyFee) / 100;
                }
                // Apply 2% fee for sells (if `from` is not the feeCollector)
                else if (from != feeCollector && to == feeCollector) {
                    feeAmount = (amount * sellFee) / 100;
                }

                uint256 amountAfterFee = amount - feeAmount;
                require(_balances[from] >= amount, "ERC20: transfer amount exceeds balance");

                unchecked {
                    _balances[from] -= amount;
                    _balances[to] += amountAfterFee;
                    if (feeAmount > 0) {
                        _balances[feeCollector] += feeAmount; // Transfer fee to feeCollector
                    }
                }

                emit Transfer(from, to, amountAfterFee);
                if (feeAmount > 0) {
                    emit Transfer(from, feeCollector, feeAmount);
                }
            }

            function _approve(
                address owner,
                address spender,
                uint256 amount
            ) internal virtual {
                require(owner != address(0), "ERC20: approve from the zero address");
                require(spender != address(0), "ERC20: approve to the zero address");

                _allowances[owner][spender] = amount;
                emit Approval(owner, spender, amount);
            }

            function _spendAllowance(
                address owner,
                address spender,
                uint256 amount
            ) internal virtual {
                uint256 currentAllowance = allowance(owner, spender);
                if (currentAllowance != type(uint256).max) {
                    require(currentAllowance >= amount, "ERC20: insufficient allowance");
                    unchecked {
                        _approve(owner, spender, currentAllowance - amount);
                    }
                }
            }
        }