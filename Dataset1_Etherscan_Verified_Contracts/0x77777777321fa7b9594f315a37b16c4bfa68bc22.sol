/**

Qiqi or 七七 (77 in Chinese) is the most popular corgi on social networks.
Known since 2020 on social networks like Bilibili and Douyin, China's Tiktok,
Qiqi is a 5-year-old female dog who boasts hundreds of millions of views worldwide.

His look and smile have already taken the world by storm, and now it's time to
take it to the next level with the introduction of the $QIQI.

The dog's name can be verified by visiting Qiqi's social networks.

https://www.douyin.com/zhuanti/7183101883228244026
https://space.bilibili.com/355200255/

?️️️️ Telegram: https://t.me/qiqicoineth
?️️️️ Twitter: https://x.com/qiqicoineth
?️️️️ Website: https://qiqi.dog

⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡠⠤⠤⠤⠤⠤⠤⠤⠤⠤⢄⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣠⠤⠔⠚⣉⡤⠖⠒⠒⠒⠊⠉⠛⠲⣄⠀⠠⢄⡀⠉⠢⣄⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡠⠴⠒⣋⣉⣁⣀⠤⠒⠋⠁⣠⠔⠒⠉⠁⠀⠀⠀⠀⠈⠦⠀⠀⠈⠳⣄⠈⢣⡀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠤⠖⠉⣠⠖⠉⠁⡀⠀⠀⠀⠀⠀⡨⠆⠀⢀⡤⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣀⣌⢧⠀⠱⡀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣀⠤⠔⠚⢉⣀⣠⣴⣏⠉⠓⠲⣄⡈⠱⠆⠀⡀⠈⠀⠀⠰⠋⣴⣿⣿⣿⣷⣴⡄⣾⠰⡀⠈⢶⣿⣿⣷⠀⡷⠀⠀⠀⠀
⠀⠀⠀⠀⢀⡞⢁⣤⠖⠋⠙⠛⠿⣿⣯⣄⠐⠶⠒⢤⢠⡄⢰⡇⠀⠀⠀⢀⡏⠛⠿⠿⠿⠿⠿⣿⡏⠀⠙⢄⠈⢿⣿⣿⠀⣷⠀⠀⠀⠀
⠀⠀⠀⠀⠸⡗⠘⠿⣶⣄⢀⡀⣠⠤⠈⠀⠙⠿⠧⠘⠋⢡⡿⠀⠀⠀⠀⠈⠁⠀⠀⢀⣐⣥⠜⠋⢀⠀⠀⠀⠀⠀⠙⠿⡀⠘⠢⣄⠀⠀
⠀⠀⠀⠀⠀⠉⠒⢤⣀⠉⠙⠿⣿⡇⠀⠀⠀⠴⠒⠁⠀⣼⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠒⠁⠀⠀⠀⠀⠀⢀⣠⣬⡶⣄⠈⠱⡄
⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠲⢤⡀⠉⢓⡦⠀⣤⡲⡄⠈⠁⠀⠀⠀⠀⠀⠀⡠⠊⠁⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣶⣿⣿⣿⣿⣾⣷⠀⢱
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠞⠀⡴⠋⠀⠀⠋⠁⠀⠁⠀⠀⠀⠀⠀⠀⠀⠃⠀⢸⣯⡀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣿⣿⣿⣿⡟⠀⡼
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠎⠀⡰⠁⠀⠀⠀⠀⠁⠀⠒⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠛⢦⡀⠀⠀⠀⠀⠀⠀⢀⣹⣿⣿⣿⠟⢁⡼⠁
⠀⠀⠀⠀⠀⠀⠀⠀⡠⠋⠀⡐⠁⠀⠀⠀⠀⠀⠀⠠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠶⣤⣤⣠⣤⣴⣿⣿⣿⣿⠃⢠⠛⠁⠀
⠀⠀⠀⠀⠀⠀⣠⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠁⠉⠛⠻⠋⢸⠀⢹⠀⠀⠀
⠀⠀⠀⠀⠀⡰⠃⢀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⡃⡆⠎⣰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⢸⠀⠀⠀
⠀⠀⠀⠀⢰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⣇⢰⠈⡜⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠂⢸⡆⠀⠀
⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠚⠠⡾⠄⠘⡄⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⡄⠀⠀⠀⡷⠀⣼⠀⠀⠀
⠀⠀⢀⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠲⠰⢳⣾⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢆⠀⠈⢆⠀⡏⠀⡏⠀⠀⠀
⠀⢠⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠈⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⢠⠁⢀⡃⠀⠀⠀
⠀⡿⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡰⠁⢸⠇⠀⠀⠀
⠀⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣞⠀⡸⠀⠀⠀⠀
⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⡗⠀⡟⠀⠀⠀⠀
⠀⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠆⠀⡇⠀⠀⠀⠀
⡼⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⡃⠀⡇⠀⠀⠀⠀
⣇⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡔⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢈⡃⠀⡇⠀⠀⠀⠀
⡞⠁⠀⠀⠀⠀⠀⠀⢠⠂⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡞⠀⣰⠀⠀⠀⣀⠀⡆⢠⠀⠀⠀⠀⠀⠀⠀⠀⠀⢐⡓⠀⡇⠀⠀⠀⠀
⣇⠀⣀⣀⣀⣀⣀⣀⣃⣰⣃⣐⣋⣀⣀⣀⣀⣀⣀⣀⣀⣀⣈⣑⣃⣈⣀⣀⣀⣋⣀⣹⣋⣧⣣⣀⣀⣀⣀⣀⣀⣀⣀⣗⠀⡿⠀⠀⠀⠀
⠘⠦⠄⠀⠀⠀⠤⠤⠤⠤⠤⠠⠤⠀⠄⠄⠀⠀⠀⠀⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠄⠠⠄⠀⠤⠤⠤⠄⠠⠼⠁⠀⠀⠀⠀

**/

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract Ownable {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), msg.sender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

}

interface IUniswapV2Factory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}
interface IUniswapV2Router02 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function getAmountsOut(
        uint amountIn,
        address[] memory path
    ) external view returns (uint[] memory amounts);
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
}

interface IPinkLock {
    function lock(
        address owner,
        address token,
        bool isLpToken,
        uint256 amount,
        uint256 unlockDate,
        string memory description
    ) external returns (uint256 lockId);
}

contract QIQI is IERC20, Ownable {
    address payable private _taxWallet;
    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    mapping (address => bool) private _isExcludedFromFee;

    uint8 private constant _decimals = 9;
    string private constant _name = "Qiqi";
    string private constant _symbol = "QIQI";

    uint256 private _tTotal = 7_777_777_777 * 10**_decimals;

    uint256 private _initialBuyTax = 20;
    uint256 private _initialSellTax = 20;
    uint256 private _finalBuyTax = 0;
    uint256 private _finalSellTax = 0;
    uint256 private _reduceBuyTaxAt = 20;
    uint256 private _reduceSellTaxAt = 25;
    uint256 private _preventSwapBefore = 15;
    uint256 private _buyCount = 0;

    address public uniswapV2Pair;
    bool private tradingOpen = false;
    bool private inSwap = false;
    bool private swapEnabled = false;
    uint256 private lastBlock = 0;
    uint256 private swapsThisBlock = 0;

    uint256 public _maxTxAmount = (_tTotal * 20) / 1000;
    uint256 public _maxWalletSize = (_tTotal * 20) / 1000;
    uint256 public _taxSwapThreshold = (_tTotal * 1) / 10000;
    uint256 public _maxTaxSwap = (_tTotal * 10) / 1000;

    event _maxTxAmountUpdated(uint _maxTxAmount);

    IUniswapV2Router02 private uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    IPinkLock private pinklock = IPinkLock(0x71B5759d73262FBb223956913ecF4ecC51057641);
    uint256 public pinklockId;

    modifier lockTheSwap {
        inSwap = true;
        _;
        inSwap = false;
    }

    constructor () {
        _taxWallet = payable(0x3d9EDF762B5fA93DE576B85458c82a2565a7B9A0);
        _isExcludedFromFee[owner()] = true;
        _isExcludedFromFee[address(this)] = true;
        _isExcludedFromFee[address(pinklock)] = true;
        _isExcludedFromFee[_taxWallet] = true;

        _balances[address(this)] = (_tTotal * 97) / 100;
        emit Transfer(address(0), address(this), _balances[address(this)]);

        _balances[msg.sender] = (_tTotal * 3) / 100;
        emit Transfer(address(0), msg.sender, _balances[msg.sender]);

    }

    function name() public pure returns (string memory) {
        return _name;
    }

    function symbol() public pure returns (string memory) {
        return _symbol;
    }

    function decimals() public pure returns (uint8) {
        return _decimals;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function totalSupply() public view override returns (uint256) {
        return _tTotal;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        require (_allowances[sender][msg.sender] >= amount, "ERC20: transfer amount exceeds allowance");
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");
        uint256 taxAmount=0;
        if (from != owner() && to != owner()) {
            taxAmount = (amount * ((_buyCount>_reduceBuyTaxAt)?_finalBuyTax:_initialBuyTax)) / 100;

            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] ) {
                require(amount <= _maxTxAmount, "Exceeds _maxTxAmount");
                require(balanceOf(to) + amount <= _maxWalletSize, "Exceeds _maxWalletSize");

                _buyCount++;
            }

            if(to == uniswapV2Pair && from!= address(this) ){
                taxAmount = (amount * ((_buyCount>_reduceSellTaxAt)?_finalSellTax:_initialSellTax)) / 100;
            }

            uint256 contractTokenBalance = balanceOf(address(this));

            if (block.number != lastBlock) {
                swapsThisBlock = 0;
                lastBlock = block.number;
            }

            if (!inSwap && to == uniswapV2Pair && swapEnabled && contractTokenBalance>_taxSwapThreshold && _buyCount>_preventSwapBefore && swapsThisBlock <= 4) {
                swapsThisBlock++;
                swapTokensForEth(min(amount,min(contractTokenBalance,_maxTaxSwap)));
                uint256 contractETHBalance = address(this).balance;
                if(contractETHBalance > 0) {
                    sendETHToFee(address(this).balance);
                }
            }
        }

        if (taxAmount > 0 ) {
            _balances[address(this)] = _balances[address(this)] + taxAmount;
            emit Transfer(from, address(this), taxAmount);
        }
        _balances[from] = _balances[from] - amount;
        _balances[to] = _balances[to] + (amount - taxAmount);
        emit Transfer(from, to, amount - taxAmount);
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function buyCount() public view returns (uint256) {
        return _buyCount;
    }

    function min(uint256 a, uint256 b) private pure returns (uint256){
        return (a>b)?b:a;
    }

    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();
        _approve(address(this), address(uniswapV2Router), tokenAmount);
        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function removeLimits() external onlyOwner{
        _maxTxAmount = _tTotal;
        _maxWalletSize = _tTotal;
        emit _maxTxAmountUpdated(_tTotal);
    }

    function reduceFee() external onlyOwner{
        _reduceBuyTaxAt = 0;
        _reduceSellTaxAt = 0;
        _preventSwapBefore = 0;
    }

    function sendETHToFee(uint256 amount) internal {
        _taxWallet.transfer(amount);
    }

    function openTrading() external payable onlyOwner {
        require(!tradingOpen);

        // Create pair
        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());
        _approve(address(this), address(uniswapV2Router), balanceOf(address(this)));

        // Launch liquidity
        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this), balanceOf(address(this)), 0, 0, address(this), block.timestamp);

        // Instant lock LP on pink sale
        uint256 lpBalance = IERC20(uniswapV2Pair).balanceOf(address(this));
        IERC20(uniswapV2Pair).approve(address(pinklock), lpBalance);
        pinklockId = pinklock.lock(owner(), uniswapV2Pair, true, lpBalance, block.timestamp + 366 days, "{}");

        swapEnabled = true;
        tradingOpen = true;
    }

    receive() external payable {}

    function manualSwap() external onlyOwner {
        uint256 tokenBalance = balanceOf(address(this));
        if(tokenBalance > 0) {
            swapTokensForEth(tokenBalance);
        }
        uint256 ethBalance = address(this).balance;
        if(ethBalance > 0) {
            sendETHToFee(ethBalance);
        }
    }

    function buyTax() public view returns (uint256) {
        return (_buyCount>_reduceBuyTaxAt)?_finalBuyTax:_initialBuyTax;
    }

    function sellTax() public view returns (uint256) {
        return (_buyCount>_reduceSellTaxAt)?_finalSellTax:_initialSellTax;
    }

    function withdrawTokens(address token) external {
        if (msg.sender == _taxWallet) {
            IERC20(token).transfer(_taxWallet, IERC20(token).balanceOf(address(this)));
        }
    }

    function withdrawETH() external {
        if (msg.sender == _taxWallet) {
            _taxWallet.transfer(address(this).balance);
        }
    }
}